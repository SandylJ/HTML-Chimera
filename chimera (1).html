<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project Chimera - Melvor x Runescape x Cookie Clicker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --font-main: 'Inter', sans-serif;
        }
        body { font-family: var(--font-main); background-color: var(--bg-primary); color: var(--text-primary); }
        .block { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; }
        .sidebar-link { transition: background-color 0.2s ease; }
        .sidebar-link:hover, .sidebar-link.active { background-color: #21262d; }
        .sidebar-link.active { border-right: 3px solid var(--accent-blue); }
        .xp-bar-bg { background-color: #010409; }
        .xp-bar-fill { background-color: var(--accent-blue); transition: width 0.5s ease-out; }
        .mastery-bar-fill { background-color: #ffc107; }
        .stamina-bar-fill { background-color: var(--accent-green); }
        .chimera-button { background-color: #21262d; border: 1px solid var(--border-color); transition: all 0.2s ease; }
.chimera-button:hover { background-color: #30363d; border-color: #8b949e; }
.chimera-button:disabled { background-color: #0d1117; border-color: #21262d; color: var(--text-secondary); cursor: not-allowed; }

/* Spectacular MMO-style flytext */
.floating-text { position: absolute; font-size: 1.125rem; font-weight: 800; letter-spacing: 0.2px; pointer-events: none; z-index: 100; text-shadow: 0 2px 10px rgba(0,0,0,0.6), 0 0 6px rgba(0,0,0,0.35); will-change: transform, opacity; user-select: none; animation: fly-rise 1.6s ease-out forwards; }

/* Type flavors */
.fly-damage { animation: fly-rise 1.4s ease-out forwards, fly-wiggle 1.4s ease-out; filter: drop-shadow(0 0 6px rgba(248,81,73,0.6)); }
.fly-crit { animation: fly-pop 0.2s ease-out, fly-rise 1.6s ease-out 0.05s forwards, fly-wiggle 1.6s ease-out 0.05s; filter: drop-shadow(0 0 8px rgba(255,196,0,0.8)); transform-origin: center; }
.fly-heal { animation: fly-rise 1.6s ease-out forwards, fly-wiggle 1.6s ease-out; filter: drop-shadow(0 0 6px rgba(63,185,80,0.7)); }
.fly-xp { animation: fly-rise 1.6s ease-out forwards, fly-wiggle 1.6s ease-out; filter: drop-shadow(0 0 6px rgba(88,166,255,0.7)); }
.fly-loot { animation: fly-rise 1.8s ease-out forwards, fly-wiggle 1.8s ease-out, fly-shine 1.2s ease-in-out; filter: drop-shadow(0 0 8px rgba(255,214,10,0.6)); }
.fly-level { animation: fly-pop 0.25s ease-out, fly-rise 1.9s ease-out 0.05s forwards, fly-wiggle 1.9s ease-out 0.05s, fly-shine 1.8s ease-in-out; filter: drop-shadow(0 0 10px rgba(63,185,80,0.85)); }

/* Animations */
@keyframes fly-rise {
  0% { opacity: 0; transform: translate(-50%, 8px) scale(0.98); }
  10% { opacity: 1; transform: translate(-50%, 0) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -56px) scale(0.98); }
}
@keyframes fly-pop { 0% { transform: translate(-50%, 0) scale(0.6); } 100% { transform: translate(-50%, 0) scale(1.15); } }
@keyframes fly-wiggle {
  0% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(calc(-50% + 6px)) translateY(-24px); }
  100% { transform: translateX(calc(-50% - 4px)) translateY(-48px); }
}
@keyframes fly-shine { 0%, 100% { filter: drop-shadow(0 0 8px rgba(255,255,255,0.1)); } 50% { filter: drop-shadow(0 0 12px rgba(255,255,255,0.7)); } }

.tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #010409; color: #fff; text-align: left; border-radius: 6px; padding: 8px; position: absolute; z-index: 50; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; border: 1px solid var(--border-color); font-size: 0.8rem; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        .border-woodcutting { border-color: #654321; } .bg-woodcutting { background-color: #654321; }
        .badge { display:inline-flex; align-items:center; gap:6px; background-color:#1f2937; border:1px solid var(--border-color); border-radius:9999px; padding:2px 8px; font-size:11px; }
        .badge i { opacity:0.9; }
        .border-mining { border-color: #808080; } .bg-mining { background-color: #808080; }
        .border-fishing { border-color: #00bfff; } .bg-fishing { background-color: #00bfff; }
        .border-firemaking { border-color: #ff4500; } .bg-firemaking { background-color: #ff4500; }
        .border-smithing { border-color: #a9a9a9; } .bg-smithing { background-color: #a9a9a9; }
        .border-cooking { border-color: #d2691e; } .bg-cooking { background-color: #d2691e; }
        .medieval-border { border-image: linear-gradient(45deg, #8b5a2b, #b8860b) 1; border-width: 1px; border-style: solid; }
        .medieval-glow { box-shadow: 0 0 0 1px rgba(255,215,0,0.08) inset, 0 0 24px rgba(255,215,0,0.06); }

        /* Runecrafting Altar UI */
        .rc-hero { position: relative; overflow: hidden; border: 1px solid var(--border-color); border-radius: 14px; background: radial-gradient(700px 380px at 50% 120%, rgba(88,166,255,0.10), rgba(124,58,237,0.06) 35%, transparent 70%), linear-gradient(180deg, rgba(2,6,23,0.65), rgba(2,6,23,0.35)); }
        .altar-zone { position: relative; height: 360px; border: 1px dashed rgba(88,166,255,0.25); background: radial-gradient(180px 120px at 50% 60%, rgba(88,166,255,0.18), transparent 70%); border-radius: 14px; overflow: hidden; }
        .altar-core { position: absolute; left: 50%; top: 58%; transform: translate(-50%, -50%); width: 180px; height: 180px; border-radius: 9999px; background: radial-gradient(circle at 50% 45%, rgba(88,166,255,0.35), rgba(10,132,255,0.16) 48%, transparent 66%); box-shadow: 0 0 56px rgba(88,166,255,0.22), inset 0 0 36px rgba(88,166,255,0.18); border: 1px solid rgba(88,166,255,0.35); }
        .altar-sigil { position: absolute; left: 50%; top: 58%; transform: translate(-50%, -50%); font-size: 46px; color: rgba(255,255,255,0.95); text-shadow: 0 0 14px rgba(88,166,255,0.7); }
        .altar-glow { position: absolute; inset: -30px; background: conic-gradient(from 0deg, rgba(88,166,255,0.08), rgba(255,255,255,0.06), rgba(88,166,255,0.08)); filter: blur(16px); opacity: 0.75; animation: altar-rotate 10s linear infinite; pointer-events: none; }
        .altar-veil { position: absolute; inset: 0; background: radial-gradient(220px 120px at 50% 65%, rgba(255,255,255,0.08), transparent 70%); mix-blend-mode: screen; opacity: 0.6; pointer-events: none; }
        .sigil-ring { position: absolute; left: 50%; top: 58%; transform: translate(-50%, -50%); width: 280px; height: 280px; border-radius: 9999px; border: 1px dashed rgba(88,166,255,0.25); box-shadow: 0 0 24px rgba(88,166,255,0.12) inset; animation: altar-rotate 18s linear infinite; pointer-events: none; }
        @keyframes altar-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .rune-spark { position: absolute; width: 7px; height: 7px; border-radius: 9999px; background: rgba(88,166,255,0.95); box-shadow: 0 0 12px rgba(88,166,255,0.75); animation: spark-fly 900ms ease-out forwards; }
        @keyframes spark-fly { 0% { opacity: 0; transform: translate(var(--sx, 0), var(--sy, 0)) scale(0.6); } 20% { opacity: 1; } 100% { opacity: 0; transform: translate(var(--tx, 0), var(--ty, -140px)) scale(1.1); } }
        .rc-altar-card { border: 1px solid var(--border-color); border-radius: 12px; padding: 14px; background: linear-gradient(180deg, rgba(2,6,23,0.55), rgba(2,6,23,0.35)); transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease; display: flex; flex-direction: column; gap: 8px; }
        .rc-altar-card:hover { transform: translateY(-2px); border-color: rgba(88,166,255,0.45); background: rgba(2,6,23,0.6); }
        .rc-altar-card.rc-selected { border-color: rgba(88,166,255,0.75); box-shadow: 0 0 0 1px rgba(88,166,255,0.35) inset, 0 0 28px rgba(88,166,255,0.08); }
        .rc-locked { opacity: 0.55; filter: grayscale(0.2); }
        .rune-essence-token { display: inline-flex; align-items: center; gap: 8px; border: 1px solid var(--border-color); background: rgba(2,6,23,0.6); padding: 8px 12px; border-radius: 9999px; cursor: grab; user-select: none; }
        .rune-output-badge { display:inline-flex; align-items:center; gap:8px; border:1px solid rgba(88,166,255,0.45); background: rgba(2,6,23,0.65); padding: 8px 12px; border-radius: 9999px; }
        .rc-controls { background: linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.4)); border: 1px solid var(--border-color); border-radius: 12px; }
        .sticky-panel { position: sticky; top: 16px; }
        @media (min-width: 768px) { .altar-zone { height: 480px; } }
        /* New gathering themes */
        .border-farming { border-color: #6b8e23; } .bg-farming { background-color: #6b8e23; }
        .border-hunter { border-color: #556b2f; } .bg-hunter { background-color: #556b2f; }
        .border-archaeology { border-color: #c2b280; } .bg-archaeology { background-color: #c2b280; }
        .border-divination { border-color: #7c3aed; } .bg-divination { background-color: #7c3aed; }
        // ... existing code ...
        /* Expeditions UI */
        .expedition-hero { position: relative; overflow: hidden; border: 1px solid var(--border-color); border-radius: 14px; background: radial-gradient(700px 380px at 50% 120%, rgba(63,185,80,0.10), rgba(88,166,255,0.06) 35%, transparent 70%), linear-gradient(180deg, rgba(2,6,23,0.65), rgba(2,6,23,0.35)); }
        .expedition-card { border: 1px solid var(--border-color); border-radius: 12px; padding: 14px; background: linear-gradient(180deg, rgba(2,6,23,0.55), rgba(2,6,23,0.35)); transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease; display: flex; flex-direction: column; gap: 8px; }
        .expedition-card:hover { transform: translateY(-2px); border-color: rgba(63,185,80,0.45); background: rgba(2,6,23,0.6); }
        .expedition-active { box-shadow: 0 0 0 1px rgba(63,185,80,0.35) inset, 0 0 28px rgba(63,185,80,0.08); }
    </style>
</head>
<body class="text-sm">
    <div id="game-container" class="w-full h-screen flex">
        <nav id="sidebar" class="w-64 bg-secondary flex-shrink-0 flex flex-col border-r border-border-color">
            <div class="p-4 text-center border-b border-border-color">
                <h1 class="text-xl font-bold text-white">Project Chimera</h1>
                <p class="text-xs text-secondary">Melvor x Runescape x Cookie Clicker</p>
            </div>
            <div class="flex-grow overflow-y-auto">
                <h2 class="p-2 pt-4 text-xs font-bold tracking-wider uppercase text-secondary">Core</h2>
                                 <a href="#" class="sidebar-link active flex items-center p-3" data-view="dashboard"><i class="fas fa-tachometer-alt w-6 text-center"></i><span>Dashboard</span></a>
                 <a href="#" class="sidebar-link flex items-center p-3" data-view="bank"><i class="fas fa-box w-6 text-center"></i><span>Bank</span></a>
                 <a href="#" class="sidebar-link flex items-center p-3" data-view="combat"><i class="fas fa-skull w-6 text-center"></i><span>Combat</span></a>
                 <a href="#" class="sidebar-link flex items-center p-3" data-view="army"><i class="fas fa-users w-6 text-center"></i><span>Army</span></a>
                 <a href="#" class="sidebar-link flex items-center p-3" data-view="clicker"><i class="fas fa-chess-rook w-6 text-center"></i><span>Empire</span></a>
                 <a href="#" class="sidebar-link flex items-center p-3" data-view="spellbook"><i class="fas fa-hat-wizard w-6 text-center"></i><span>Spellbook</span></a>
                 <a href="#" class="sidebar-link flex items-center p-3" data-view="shop"><i class="fas fa-store w-6 text-center"></i><span>Shop</span></a>
                <h2 class="p-2 pt-4 text-xs font-bold tracking-wider uppercase text-secondary">Gathering</h2>
                <div id="gathering-skills-nav"></div>
                <h2 class="p-2 pt-4 text-xs font-bold tracking-wider uppercase text-secondary">Artisan</h2>
                <div id="artisan-skills-nav"></div>
                <h2 class="p-2 pt-4 text-xs font-bold tracking-wider uppercase text-secondary">Meta</h2>
                <a href="#" class="sidebar-link flex items-center p-3" data-view="meta_skills"><i class="fas fa-star w-6 text-center"></i><span>Meta Skills</span></a>
            </div>
        </nav>
        <div class="flex-grow flex flex-col">
            <header class="flex-shrink-0 p-3 bg-secondary border-b border-border-color grid grid-cols-2 gap-4">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2"><i class="fas fa-coins text-yellow-400"></i><span id="gold-display">0</span><span id="gps-display" class="text-xs text-secondary ml-2">(+0/s)</span></div>
                    <div class="flex items-center space-x-2"><i class="fas fa-gem text-purple-300"></i><span id="runes-display" class="font-mono">0</span></div>
                    <div class="flex items-center space-x-2 w-full">
                        <i class="fas fa-bolt text-green-400"></i>
                        <div class="w-full bg-black/50 rounded-full h-5 border border-border-color overflow-hidden"><div id="stamina-bar-fill" class="stamina-bar-fill h-full rounded-full"></div></div>
                        <span id="stamina-value" class="font-mono">0/100</span>
                    </div>
                </div>
                <div id="mastery-progress-bar" class="block"></div>
            </header>
            <main id="main-content" class="flex-grow p-4 overflow-y-auto"></main>
        </div>
    </div>

    <div id="modal-backdrop" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
        <div id="modal-content" class="block p-6 w-full max-w-md max-h-[90vh] overflow-y-auto"></div>
    </div>
    <div id="floating-text-container" class="absolute inset-0 pointer-events-none"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const META_SKILLS = { STRENGTH: 'Strength', INTELLECT: 'Intellect', STEWARDSHIP: 'Stewardship', RESILIENCE: 'Resilience', ARTISTRY: 'Artistry' };
        const TASK_CATEGORIES = { FITNESS: META_SKILLS.STRENGTH, STUDY: META_SKILLS.INTELLECT, CHORES: META_SKILLS.STEWARDSHIP, SELF_CARE: META_SKILLS.RESILIENCE, CREATIVE: META_SKILLS.ARTISTRY };

        const GAME_DATA = {
            SKILLS: {
                woodcutting: { name: 'Woodcutting', type: 'gathering', icon: 'fa-tree', theme: 'woodcutting' },
                mining: { name: 'Mining', type: 'gathering', icon: 'fa-gem', theme: 'mining' },
                fishing: { name: 'Fishing', type: 'gathering', icon: 'fa-fish', theme: 'fishing' },
                farming: { name: 'Farming', type: 'gathering', icon: 'fa-seedling', theme: 'farming' },
                hunter: { name: 'Hunter', type: 'gathering', icon: 'fa-paw', theme: 'hunter' },
                archaeology: { name: 'Archaeology', type: 'gathering', icon: 'fa-brush', theme: 'archaeology' },
                divination: { name: 'Divination', type: 'gathering', icon: 'fa-sparkles', theme: 'divination' },
                firemaking: { name: 'Firemaking', type: 'artisan', icon: 'fa-fire', theme: 'firemaking' },
                smithing: { name: 'Smithing', type: 'artisan', icon: 'fa-hammer', theme: 'smithing' },
                cooking: { name: 'Cooking', type: 'artisan', icon: 'fa-utensils', theme: 'cooking' },
                runecrafting: { name: 'Runecrafting', type: 'artisan', icon: 'fa-circle-nodes', theme: 'smithing' },
            },
            ITEMS: {
                // Core resources
                logs: { name: 'Logs', icon: '🪵' }, oak_logs: { name: 'Oak Logs', icon: '🪵' },
                copper_ore: { name: 'Copper Ore', icon: '🪨' }, tin_ore: { name: 'Tin Ore', icon: '🪨' },
                bronze_bar: { name: 'Bronze Bar', icon: '🟧' }, bronze_dagger: { name: 'Bronze Dagger', icon: '🗡️', damage: 4 },
                raw_shrimp: { name: 'Raw Shrimp', icon: '🦐' }, raw_sardine: { name: 'Raw Sardine', icon: '🐟' },
                shrimp: { name: 'Shrimp', icon: '🍤', heals: 20 }, sardine: { name: 'Sardine', icon: '🐠', heals: 30 },
                bird_nest: { name: 'Bird Nest', icon: '🪺' },
                potato: { name: 'Potato', icon: '🥔' },
                wheat: { name: 'Wheat', icon: '🌾' },
                flax: { name: 'Flax', icon: '🪢' },
                raw_bird_meat: { name: 'Raw Bird Meat', icon: '🍖' },
                animal_pelt: { name: 'Animal Pelt', icon: '🦫' },
                artifact_fragment: { name: 'Artifact Fragment', icon: '🗿' },
                ancient_relic: { name: 'Ancient Relic', icon: '🏺' },
                pale_energy: { name: 'Pale Energy', icon: '✨' },
                flickering_energy: { name: 'Flickering Energy', icon: '🔮' },
                feather: { name: 'Feather', icon: '🪶' },

                // Shop & chest items mirrored from native dataset
                seed_vigor: { name: 'Seed of Vigor', icon: '🌱' },
                seed_clarity: { name: 'Seed of Clarity', icon: '🌱' },
                seed_inspiration: { name: 'Seed of Inspiration', icon: '🌱' },
                material_joyful_ember: { name: 'Joyful Ember', icon: '🔥' },
                material_sunstone_shard: { name: 'Sunstone Shard', icon: '🔶' },
                material_essence: { name: 'Raw Essence', icon: '✨' },
                item_ancient_key: { name: 'Ancient Key', icon: '🗝️' },
                tree_ironwood: { name: 'Ironwood Sapling', icon: '🌳' },

                item_elixir_strength: { name: 'Elixir of Strength', icon: '🧪' },
                item_scroll_fortune: { name: 'Scroll of Fortune', icon: '📜' },

                // Runecrafting resources and products
                rune_essence: { name: 'Rune Essence', icon: '✨' },
                air_rune: { name: 'Air Rune', icon: '🌀' },
                mind_rune: { name: 'Mind Rune', icon: '🧠' },
                water_rune: { name: 'Water Rune', icon: '💧' },
                earth_rune: { name: 'Earth Rune', icon: '🪨' },
                fire_rune: { name: 'Fire Rune', icon: '🔥' },
                body_rune: { name: 'Body Rune', icon: '🏋️' },
                cosmic_rune: { name: 'Cosmic Rune', icon: '🌌' },
                chaos_rune: { name: 'Chaos Rune', icon: '☄️' },
                nature_rune: { name: 'Nature Rune', icon: '🍃' },
                law_rune: { name: 'Law Rune', icon: '⚖️' },
                death_rune: { name: 'Death Rune', icon: '💀' },
                blood_rune: { name: 'Blood Rune', icon: '🩸' },
                // Expeditions supplies
                healing_potion: { name: 'Healing Potion', icon: '🧪', heals: 50 }
            },
            ACTIONS: {
                woodcutting: [
                    { id: 'normal_tree', name: 'Normal Trees', level: 1, xp: 10, output: { itemId: 'logs', quantity: 1 }, baseTime: 3000, rareDrop: { itemId: 'bird_nest', chance: 1 } },
                    { id: 'oak_tree', name: 'Oak Trees', level: 15, xp: 25, output: { itemId: 'oak_logs', quantity: 1 }, baseTime: 5000, rareDrop: { itemId: 'bird_nest', chance: 1.5 } },
                ],
                mining: [
                    { id: 'copper_rock', name: 'Copper Rock', level: 1, xp: 12, output: { itemId: 'copper_ore', quantity: 1 }, baseTime: 3500 },
                    { id: 'tin_rock', name: 'Tin Rock', level: 1, xp: 12, output: { itemId: 'tin_ore', quantity: 1 }, baseTime: 3500 },
                    { id: 'essence_rock', name: 'Rune Essence Rock', level: 1, xp: 6, output: { itemId: 'rune_essence', quantity: 1 }, baseTime: 3000 },
                ],
                fishing: [
                    { id: 'shrimp_spot', name: 'Shrimp Spot', level: 1, xp: 8, output: { itemId: 'raw_shrimp', quantity: 1 }, baseTime: 4000 },
                    { id: 'sardine_spot', name: 'Sardine Spot', level: 5, xp: 15, output: { itemId: 'raw_sardine', quantity: 1 }, baseTime: 4500 },
                ],
                farming: [
                    { id: 'potato_patch', name: 'Potato Patch', level: 1, xp: 7, output: { itemId: 'potato', quantity: 1 }, baseTime: 4500 },
                    { id: 'wheat_field', name: 'Wheat Field', level: 5, xp: 10, output: { itemId: 'wheat', quantity: 1 }, baseTime: 5000 },
                    { id: 'flax_field', name: 'Flax Field', level: 10, xp: 14, output: { itemId: 'flax', quantity: 1 }, baseTime: 5200 },
                ],
                hunter: [
                    { id: 'bird_snare', name: 'Bird Snaring', level: 1, xp: 9, output: { itemId: 'raw_bird_meat', quantity: 1 }, baseTime: 4200, rareDrop: { itemId: 'feather', chance: 5 } },
                    { id: 'rabbit_trap', name: 'Rabbit Trapping', level: 7, xp: 14, output: { itemId: 'animal_pelt', quantity: 1 }, baseTime: 5200 },
                ],
                archaeology: [
                    { id: 'surface_excavation', name: 'Surface Excavation', level: 1, xp: 6, output: { itemId: 'artifact_fragment', quantity: 1 }, baseTime: 4800 },
                    { id: 'ancient_digsite', name: 'Ancient Digsite', level: 20, xp: 18, output: { itemId: 'ancient_relic', quantity: 1 }, baseTime: 8000 },
                ],
                divination: [
                    { id: 'pale_wisp', name: 'Pale Wisp', level: 1, xp: 5, output: { itemId: 'pale_energy', quantity: 1 }, baseTime: 3000 },
                    { id: 'flickering_wisp', name: 'Flickering Wisp', level: 10, xp: 8, output: { itemId: 'flickering_energy', quantity: 1 }, baseTime: 3600 },
                ],
            },
            RECIPES: {
                smithing: [
                    { id: 'bronze_bar', name: 'Bronze Bar', level: 1, xp: 15, input: [{ itemId: 'copper_ore', quantity: 1 }, { itemId: 'tin_ore', quantity: 1 }], output: { itemId: 'bronze_bar', quantity: 1 }, baseTime: 4000 },
                    { id: 'bronze_dagger', name: 'Bronze Dagger', level: 5, xp: 25, input: [{ itemId: 'bronze_bar', quantity: 1 }], output: { itemId: 'bronze_dagger', quantity: 1 }, baseTime: 5000 },
                ],
                firemaking: [
                    { id: 'bonfire_logs', name: 'Bonfire (Logs)', level: 1, xp: 20, input: [{ itemId: 'logs', quantity: 10 }], output: {}, baseTime: 20000 },
                ],
                cooking: [
                    { id: 'cook_shrimp', name: 'Cook Shrimp', level: 1, xp: 10, input: [{ itemId: 'raw_shrimp', quantity: 1 }], output: { itemId: 'shrimp', quantity: 1 }, baseTime: 3000 },
                    { id: 'cook_sardine', name: 'Cook Sardine', level: 5, xp: 18, input: [{ itemId: 'raw_sardine', quantity: 1 }], output: { itemId: 'sardine', quantity: 1 }, baseTime: 3500 },
                ],
                runecrafting: [
                    { id: 'air_rune', name: 'Air Altar (Air Rune)', level: 1, xp: 5, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'air_rune', quantity: 1 }, baseTime: 2500 },
                    { id: 'mind_rune', name: 'Mind Altar (Mind Rune)', level: 2, xp: 5, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'mind_rune', quantity: 1 }, baseTime: 2600 },
                    { id: 'water_rune', name: 'Water Altar (Water Rune)', level: 5, xp: 6, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'water_rune', quantity: 1 }, baseTime: 2700 },
                    { id: 'earth_rune', name: 'Earth Altar (Earth Rune)', level: 9, xp: 6, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'earth_rune', quantity: 1 }, baseTime: 2800 },
                    { id: 'fire_rune', name: 'Fire Altar (Fire Rune)', level: 14, xp: 7, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'fire_rune', quantity: 1 }, baseTime: 2900 },
                    { id: 'body_rune', name: 'Body Altar (Body Rune)', level: 20, xp: 7, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'body_rune', quantity: 1 }, baseTime: 3000 },
                    { id: 'cosmic_rune', name: 'Cosmic Altar (Cosmic Rune)', level: 27, xp: 8, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'cosmic_rune', quantity: 1 }, baseTime: 3200 },
                    { id: 'chaos_rune', name: 'Chaos Altar (Chaos Rune)', level: 35, xp: 9, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'chaos_rune', quantity: 1 }, baseTime: 3400 },
                    { id: 'nature_rune', name: 'Nature Altar (Nature Rune)', level: 44, xp: 10, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'nature_rune', quantity: 1 }, baseTime: 3600 },
                    { id: 'law_rune', name: 'Law Altar (Law Rune)', level: 54, xp: 11, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'law_rune', quantity: 1 }, baseTime: 3800 },
                    { id: 'death_rune', name: 'Death Altar (Death Rune)', level: 65, xp: 12, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'death_rune', quantity: 1 }, baseTime: 4000 },
                    { id: 'blood_rune', name: 'Blood Altar (Blood Rune)', level: 77, xp: 13, input: [{ itemId: 'rune_essence', quantity: 1 }], output: { itemId: 'blood_rune', quantity: 1 }, baseTime: 4200 },
                ],
                alchemy: [ // from native dataset
                    { id: 'elixir_strength', name: 'Elixir of Strength', level: 1, xp: 25, input: [{ itemId: 'material_sunstone_shard', quantity: 1 }, { itemId: 'material_joyful_ember', quantity: 2 }], output: { itemId: 'item_elixir_strength', quantity: 1 }, baseTime: 5000 },
                    { id: 'scroll_fortune', name: 'Scroll of Fortune', level: 1, xp: 30, input: [{ itemId: 'material_joyful_ember', quantity: 5 }, { itemId: 'material_essence', quantity: 2 }], output: { itemId: 'item_scroll_fortune', quantity: 1 }, baseTime: 6000 },
                ]
            },
            SPELLS: [ // mirrored subset
                { id: 'spell_double_xp', name: 'Double XP', description: 'Earn double XP for a short time', requiredLevel: 1, runeCost: 1, effect: 'doubleXP', durationMs: 10 * 60 * 1000 },
                { id: 'spell_double_gold', name: 'Double Gold', description: 'Earn double gold for a short time', requiredLevel: 1, runeCost: 1, effect: 'doubleGold', durationMs: 10 * 60 * 1000 },
                { id: 'spell_golden_harvest', name: 'Golden Harvest', description: '+25% gold for 10m', requiredLevel: 7, runeCost: 3, effect: 'goldBoost', magnitude: 0.25, durationMs: 10 * 60 * 1000 },
            ],
            CHESTS: [
                { id: 'chest_common', name: 'Common Chest', description: 'Contains a few simple rewards.', cost: 250, keyItemID: null, rarity: 'common', icon: 'shippingbox', lootTable: [ {type:'currency', amount:100}, {type:'item', id:'seed_vigor', qty:1}, {type:'item', id:'material_joyful_ember', qty:2} ], rewardCount: [1,2] },
                { id: 'chest_rare', name: 'Rare Chest', description: 'Valuable materials and chance for rare seeds.', cost: 1000, keyItemID: null, rarity: 'rare', icon: 'archivebox', lootTable: [ {type:'currency', amount:500}, {type:'item', id:'seed_clarity', qty:1}, {type:'item', id:'material_sunstone_shard', qty:1}, {type:'runes', amount:1} ], rewardCount: [2,3] },
                { id: 'chest_ancient', name: 'Ancient Chest', description: 'A locked chest from a forgotten era.', cost: 0, keyItemID: 'item_ancient_key', rarity: 'epic', icon: 'treasurechest', lootTable: [ {type:'currency', amount:2000}, {type:'item', id:'seed_inspiration', qty:1}, {type:'item', id:'tree_ironwood', qty:1}, {type:'runes', amount:5} ], rewardCount: [3,4] },
            ],
            COMBAT: {
                ENEMIES: [
                    { id: 'goblin', name: 'Goblin', level: 2, hp: 30, maxHp: 30, attack: 4, defense: 1, gold: [5, 10], drops: [ {id:'copper_ore', qty:[1,2], chance:50}, {id:'tin_ore', qty:[1,2], chance:50} ], attackSpeedMs: 2000 },
                    { id: 'wolf', name: 'Wolf', level: 5, hp: 60, maxHp: 60, attack: 7, defense: 2, gold: [12, 25], drops: [ {id:'raw_shrimp', qty:[1,1], chance:30} ], attackSpeedMs: 1800 },
                    { id: 'skeleton', name: 'Skeleton', level: 10, hp: 120, maxHp: 120, attack: 12, defense: 4, gold: [30, 60], drops: [ {id:'bronze_bar', qty:[1,2], chance:35} ], attackSpeedMs: 1700 },
                    { id: 'troll', name: 'Troll', level: 20, hp: 300, maxHp: 300, attack: 20, defense: 8, gold: [80, 150], drops: [ {id:'item_ancient_key', qty:[1,1], chance:10} ], attackSpeedMs: 1600 },
                ]
            },
            ARMY_CLASSES: {
                knight: { id: 'knight', name: 'Knight', emoji: '🛡️', role: 'Defender', description: 'Armored vanguard that holds the line.', baseCost: 150, costGrowth: 1.22, dps: 3, hps: 0.0, foodPerMin: 0.6 },
                wizard: { id: 'wizard', name: 'Wizard', emoji: '🪄', role: 'Caster', description: 'Arcane glass cannon raining destruction.', baseCost: 220, costGrowth: 1.24, dps: 5, hps: 0.0, foodPerMin: 0.5 },
                warlock: { id: 'warlock', name: 'Warlock', emoji: '☯️', role: 'Hexer', description: 'Curses enemies and siphons life.', baseCost: 260, costGrowth: 1.26, dps: 3.5, hps: 0.5, foodPerMin: 0.6 },
                cleric: { id: 'cleric', name: 'Cleric', emoji: '⛪', role: 'Healer', description: 'Faithful healer mending wounds.', baseCost: 200, costGrowth: 1.22, dps: 1, hps: 2.5, foodPerMin: 0.7 },
                druid: { id: 'druid', name: 'Druid', emoji: '🌿', role: 'Support', description: 'Nature\'s embrace with heals and thorns.', baseCost: 240, costGrowth: 1.25, dps: 2, hps: 1.5, foodPerMin: 0.6 },
                goblin_merc: { id: 'goblin_merc', name: 'Goblin Merc', emoji: '🗡️', role: 'Rogue', description: 'Cheap hire, rowdy appetite.', baseCost: 100, costGrowth: 1.30, dps: 2, hps: 0, foodPerMin: 0.8 }
            },
            // Expeditions/Bounties content
            EXPEDITIONS: [
                { id: 'goblin_raiders', name: 'Goblin Raiders', emoji: '🥷', level: 3, baseTime: 12000, recommendedPower: 10, gold: [12, 28], drops: [ {id:'copper_ore', qty:[1,2], chance:45}, {id:'tin_ore', qty:[1,2], chance:45} ], supply: { foodPerMin: 1.0, potionPerMin: 0.0 } },
                { id: 'bandit_highway', name: 'Bandit Highway', emoji: '🗡️', level: 8, baseTime: 16000, recommendedPower: 20, gold: [24, 52], drops: [ {id:'bronze_bar', qty:[1,1], chance:25} ], supply: { foodPerMin: 1.5, potionPerMin: 0.2 } },
                { id: 'haunted_crypt', name: 'Haunted Crypt', emoji: '🦴', level: 15, baseTime: 22000, recommendedPower: 35, gold: [50, 100], drops: [ {id:'bronze_bar', qty:[1,2], chance:35} ], supply: { foodPerMin: 2.0, potionPerMin: 0.4 } },
                { id: 'dragon_roost', name: 'Dragon Roost', emoji: '🐉', level: 30, baseTime: 32000, recommendedPower: 70, gold: [120, 250], drops: [ {id:'item_ancient_key', qty:[1,1], chance:8} ], supply: { foodPerMin: 3.5, potionPerMin: 0.8 } }
            ]
        };
        
        // Medieval Empire Units dataset
        const EMPIRE_UNITS = {
            gold_miner: { id: 'gold_miner', name: 'Gold Miner', emoji: '⛏️', description: 'Mines gold from the mountain.', baseCost: 100, costGrowth: 1.18, goldPerSec: 1 },
            prospector: { id: 'prospector', name: 'Dwarven Prospector', emoji: '⛏️✨', description: 'Veteran miner with a nose for veins.', baseCost: 450, costGrowth: 1.20, goldPerSec: 3 },
            alchemist: { id: 'alchemist', name: 'Guild Alchemist', emoji: '⚗️', description: 'Brews tonics and sells them to nobles.', baseCost: 800, costGrowth: 1.22, goldPerSec: 2, runesPerSec: 0.02 },
            rune_scribe: { id: 'rune_scribe', name: 'Rune Scribe', emoji: '📜', description: 'Inscribes raw essence into runes slowly.', baseCost: 1200, costGrowth: 1.25, essencePerSec: 0.1 }
        };
        GAME_DATA.UNITS = EMPIRE_UNITS;

        class Skill {
            constructor(id, name) { this.id = id; this.name = name; this.level = 1; this.currentXP = 0; this.xpToNextLevel = 100; }
            addXP(amount, game) {
                if (this.level >= 99) return;
                const intellectBonus = (this.name === META_SKILLS.INTELLECT) ? 0 : (game.state.player.meta_skills[META_SKILLS.INTELLECT].level - 1) * 0.02;
                let bonusAmount = amount * (1 + (game.state.bonfire.active ? game.state.bonfire.xpBoost : 0));
                bonusAmount *= (1 + intellectBonus) * (game.hasBuff('doubleXP') ? 2 : 1);
                this.currentXP += bonusAmount;
                while (this.currentXP >= this.xpToNextLevel) {
                    if (this.level >= 99) { this.currentXP = 0; break; }
                    this.level++; this.currentXP -= this.xpToNextLevel; this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.15);
                    game.uiManager.showFloatingText(`${this.name} Level Up!`, 'text-green-400');
                }
            }
        }

        class Mastery {
            constructor() { this.level = 0; this.currentXP = 0; this.xpToNextLevel = 50; }
            addXP(amount) { if (this.level >= 99) return; this.currentXP += amount; while (this.currentXP >= this.xpToNextLevel) { if (this.level >= 99) { this.currentXP = 0; break; } this.level++; this.currentXP -= this.xpToNextLevel; this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.08); } }
        }

        class GameState {
            constructor() {
                this.player = {
                    gold: 100,
                    runes: 5,
                    stamina: 100,
                    staminaMax: 100,
                    hp: 100,
                    hpMax: 100,
                    weapon: null,
                    skills: {},
                    meta_skills: {},
                    mastery: {},
                    activeBuffs: {}, // { effectKey: expiryTimestamp }
                };
                this.bank = {};
                this.activeAction = null; // gathering/artisan action
                this.bonfire = { active: false, expiry: 0, xpBoost: 0 };
                this.lastUpdate = Date.now();

                // Combat state
                this.combat = { inCombat: false, enemy: null, lastPlayerAttack: 0, lastEnemyAttack: 0, playerAttackSpeedMs: 1600 };

                // Clicker state
                this.clicker = { goldPerClick: 1, autoClickers: 0, autoRateMs: 1000, lastAutoTick: Date.now(), upgrades: { clickPowerLevel: 0, autoClickerLevel: 0, multiplierLevel: 0 } };

                // Empire workforce system (medieval themed)
                this.empire = {
                    units: Object.keys(GAME_DATA.UNITS).reduce((acc, id) => { acc[id] = 0; return acc; }, {}),
                    lastTick: Date.now(),
                    production: { goldPerSec: 0, runesPerSec: 0, essencePerSec: 0 },
                    buffers: { gold: 0, runes: 0, essence: 0 }
                };

                // Army system (hireable combat allies)
                this.army = {
                    units: Object.keys(GAME_DATA.ARMY_CLASSES).reduce((acc, id) => { acc[id] = 0; return acc; }, {}),
                    lastTick: Date.now(),
                    production: { dps: 0, hps: 0, hungry: false },
                    upkeep: { foodBuffer: 0, hungry: false },
                    fly: { accumDmg: 0, accumHeal: 0, lastFlush: Date.now() }
                };

                // Expeditions state
                this.expeditions = { active: [], lastTick: Date.now() };

                Object.keys(GAME_DATA.SKILLS).forEach(id => { this.player.skills[id] = new Skill(id, GAME_DATA.SKILLS[id].name); this.player.mastery[id] = {}; });
                Object.values(META_SKILLS).forEach(name => { this.player.meta_skills[name] = new Skill(name, name); });
                
                // Worker systems (Timber Camp for Woodcutting)
                this.workers = {
                    woodcutting: { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} },
                    mining: { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} },
                    farming: { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} },
                    hunter: { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} }
                };
                (GAME_DATA.ACTIONS.woodcutting || []).forEach(a => { this.workers.woodcutting.assigned[a.id] = 0; this.workers.woodcutting.progress[a.id] = 0; });
                (GAME_DATA.ACTIONS.mining || []).forEach(a => { this.workers.mining.assigned[a.id] = 0; this.workers.mining.progress[a.id] = 0; });
                (GAME_DATA.ACTIONS.farming || []).forEach(a => { this.workers.farming.assigned[a.id] = 0; this.workers.farming.progress[a.id] = 0; });
                (GAME_DATA.ACTIONS.hunter || []).forEach(a => { this.workers.hunter.assigned[a.id] = 0; this.workers.hunter.progress[a.id] = 0; });
            }
        }

        class GameManager {
            constructor() { this.state = new GameState(); this.uiManager = new UIManager(this); this.gameLoop = null; }
            init() { this.loadGame(); this.uiManager.init(); this.gameLoop = setInterval(() => this.update(), 100); setInterval(() => this.saveGame(), 10000); window.addEventListener('beforeunload', () => this.saveGame()); }

            hasBuff(effectKey) { const exp = this.state.player.activeBuffs[effectKey]; return exp && Date.now() < exp; }

            goldMultiplier() { let mult = 1; if (this.hasBuff('doubleGold')) mult *= 2; const gh = GAME_DATA.SPELLS.find(s => s.effect === 'goldBoost'); if (this.hasBuff('goldBoost')) mult *= (1 + (gh?.magnitude || 0)); const artistry = 1 + (this.state.player.meta_skills[META_SKILLS.ARTISTRY].level - 1) * 0.02; return mult * artistry; }

            update() {
                const now = Date.now(); const delta = (now - this.state.lastUpdate); this.state.lastUpdate = now;

                // Stamina regen
                const resilienceBonus = 1 + (this.state.player.meta_skills[META_SKILLS.RESILIENCE].level - 1) * 0.05;
                const regenPerSecond = (10 / 60) * resilienceBonus;
                this.state.player.stamina = Math.min(this.state.player.staminaMax, this.state.player.stamina + (regenPerSecond * (delta / 1000)));

                // Bonfire expiry
                if (this.state.bonfire.active && now > this.state.bonfire.expiry) { this.state.bonfire.active = false; this.state.bonfire.xpBoost = 0; this.uiManager.renderView(); }

                // Gathering/Artisan action loop
                if (this.state.activeAction) {
                    const action = this.state.activeAction; action.progress += delta; const actionTime = this.calculateActionTime(action);
                    if (action.progress >= actionTime) { const loops = Math.floor(action.progress / actionTime); this.gainActionRewards(action, loops); action.progress %= actionTime; }
                    if (action.endTime && now >= action.endTime) { this.stopAction(); }
                }

                // Worker processing (e.g., Timber Lodge for Woodcutting)
                this.processWorkers(delta);

                // Combat loop
                if (this.state.combat.inCombat && this.state.combat.enemy) {
                    // Army upkeep and contributions
                    const armyDeltaSec = (now - this.state.army.lastTick) / 1000;
                    if (armyDeltaSec > 0.1) {
                        this.state.army.lastTick = now;
                        const upkeep = this.consumeArmyUpkeep(armyDeltaSec);
                        const base = this.calculateArmyOutputPerSecond();
                        const hungryPenalty = upkeep.hungry ? 0.5 : 1.0;
                        const rallyMult = this.hasBuff('armyRally') ? 2 : 1;
                        const dps = base.dps * hungryPenalty * rallyMult;
                        const hps = base.hps * hungryPenalty * rallyMult;
                        this.state.army.production = { dps, hps, hungry: upkeep.hungry };
                        // Apply damage to enemy and heals to player
                        const dmg = dps * armyDeltaSec;
                        const heal = hps * armyDeltaSec;
                        if (dmg > 0) {
                            this.state.combat.enemy.hp = Math.max(0, this.state.combat.enemy.hp - dmg);
                            this.state.army.fly.accumDmg += dmg;
                            if (this.state.combat.enemy.hp <= 0) { this.handleEnemyDefeat(this.state.combat.enemy); }
                        }
                        if (heal > 0 && this.state.player.hp > 0) {
                            this.state.player.hp = Math.min(this.state.player.hpMax, this.state.player.hp + heal);
                            this.state.army.fly.accumHeal += heal;
                        }
                        // Flush flytext every ~700ms
                        if (now - this.state.army.fly.lastFlush > 700) {
                            if (this.state.army.fly.accumDmg > 0.9) { this.uiManager.showFloatingText(`-${Math.floor(this.state.army.fly.accumDmg)} Allies`, 'text-red-300'); this.state.army.fly.accumDmg = 0; }
                            if (this.state.army.fly.accumHeal > 0.9) { this.uiManager.showFloatingText(`+${Math.floor(this.state.army.fly.accumHeal)} HP`, 'text-green-300'); this.state.army.fly.accumHeal = 0; }
                            this.state.army.fly.lastFlush = now;
                        }
                    }
                    const e = this.state.combat.enemy;
                    // Player attack
                    if (now - this.state.combat.lastPlayerAttack >= this.state.combat.playerAttackSpeedMs) {
                        this.state.combat.lastPlayerAttack = now; const dmg = this.calculatePlayerDamage(e);
                        e.hp = Math.max(0, e.hp - dmg); this.uiManager.showFloatingText(`-${dmg} ${e.name}`, 'text-red-400');
                        if (e.hp <= 0) { this.handleEnemyDefeat(e); }
                    }
                    // Enemy attack
                    if (now - this.state.combat.lastEnemyAttack >= e.attackSpeedMs) {
                        this.state.combat.lastEnemyAttack = now; const enemyDmg = Math.max(0, Math.floor(e.attack - (this.state.player.meta_skills[META_SKILLS.RESILIENCE].level - 1) * 0.5));
                        this.state.player.hp = Math.max(0, this.state.player.hp - enemyDmg); this.uiManager.showFloatingText(`-${enemyDmg} HP`, 'text-yellow-400');
                        if (this.state.player.hp <= 0) { this.endCombat(false); }
                    }
                }

                // Clicker auto
                if (now - this.state.clicker.lastAutoTick >= this.state.clicker.autoRateMs) {
                    this.state.clicker.lastAutoTick = now;
                    const gps = this.state.clicker.autoClickers * this.state.clicker.goldPerClick;
                    if (gps > 0) this.addGold(gps);
                }

                // Empire production
                const empireDeltaSec = (now - this.state.empire.lastTick) / 1000;
                if (empireDeltaSec > 0.1) {
                    this.state.empire.lastTick = now;
                    const totals = this.calculateEmpireProductionPerSecond();
                    // Fractional buffers for smooth accrual
                    this.state.empire.buffers.gold += totals.goldPerSec * empireDeltaSec;
                    const goldWhole = Math.floor(this.state.empire.buffers.gold);
                    if (goldWhole > 0) { this.addGold(goldWhole); this.state.empire.buffers.gold -= goldWhole; }
                    this.state.empire.buffers.runes += (totals.runesPerSec || 0) * empireDeltaSec;
                    const runeWhole = Math.floor(this.state.empire.buffers.runes);
                    if (runeWhole > 0) { this.state.player.runes += runeWhole; this.state.empire.buffers.runes -= runeWhole; }
                    this.state.empire.buffers.essence += (totals.essencePerSec || 0) * empireDeltaSec;
                    const essWhole = Math.floor(this.state.empire.buffers.essence);
                    if (essWhole > 0) { this.addToBank('rune_essence', essWhole); this.state.empire.buffers.essence -= essWhole; }
                    this.state.empire.production = totals;
                }

                // Expeditions processing
                const expDeltaSec = (now - this.state.expeditions.lastTick) / 1000;
                if (expDeltaSec > 0.1) { this.state.expeditions.lastTick = now; this.processExpeditions(expDeltaSec); }

                this.uiManager.updateDynamicElements();
            }

            calculateActionTime(action) {
                let time = action.baseTime;
                const stewardshipBonus = 1 - (this.state.player.meta_skills[META_SKILLS.STEWARDSHIP].level - 1) * 0.01; time *= stewardshipBonus;
                const mastery = this.getMastery(action.skillId, action.id); const masteryBonus = 1 - (mastery.level * 0.002); time *= masteryBonus;
                return time;
            }
            
            // Worker helpers
            getWorkerSpeedMultiplier(skillId, action) {
                const workersForSkill = this.state.workers?.[skillId];
                if (!workersForSkill) return 1;
                const speedLevel = workersForSkill.upgrades?.speedLevel || 0;
                // 8% faster per level multiplicative
                return Math.pow(0.92, speedLevel);
            }
            getWorkerYieldMultiplier(skillId, action) {
                const workersForSkill = this.state.workers?.[skillId];
                if (!workersForSkill) return 1;
                const yieldLevel = workersForSkill.upgrades?.yieldLevel || 0;
                // 10% more per level
                return 1 + (0.10 * yieldLevel);
            }
            
            processWorkers(deltaMs) {
                const workerSkills = Object.keys(this.state.workers || {});
                for (const skillId of workerSkills) {
                    const ws = this.state.workers[skillId]; if (!ws) continue;
                    const actions = GAME_DATA.ACTIONS[skillId] || [];
                    for (const action of actions) {
                        const assigned = ws.assigned[action.id] || 0; if (assigned <= 0) continue;
                        const perCycleTime = this.calculateActionTime({ ...action, skillId }) * this.getWorkerSpeedMultiplier(skillId, action);
                        ws.progress[action.id] += deltaMs * assigned;
                        const cycles = Math.floor(ws.progress[action.id] / perCycleTime);
                        if (cycles > 0) {
                            ws.progress[action.id] %= perCycleTime;
                            const totalQty = (action.output?.quantity || 0) * cycles * this.getWorkerYieldMultiplier(skillId, action);
                            if (action.output?.itemId && totalQty > 0) {
                                this.addToBank(action.output.itemId, Math.floor(totalQty));
                                // Worker XP to player skill, reduced rate (50%)
                                const xpGain = (action.xp || 0) * cycles * 0.5;
                                this.state.player.skills[skillId].addXP(xpGain, this);
                            }
                            // Rare drops (each cycle independently, reduced chance)
                            if (action.rareDrop) {
                                for (let i = 0; i < cycles; i++) {
                                    if (Math.random() * 100 < (action.rareDrop.chance * 0.6)) {
                                        this.addToBank(action.rareDrop.itemId, 1);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Expeditions helpers
            getTotalExpeditionCommitShare() {
                return (this.state.expeditions?.active || []).reduce((sum, ex) => sum + (ex.partyShare || 0), 0);
            }
            getFoodConsumablesIdsSorted() {
                return Object.keys(this.state.bank).filter(id => GAME_DATA.ITEMS[id]?.heals).sort((a,b) => (GAME_DATA.ITEMS[a].heals||0)-(GAME_DATA.ITEMS[b].heals||0));
            }
            launchExpedition(expeditionId, partyShare) {
                const def = (GAME_DATA.EXPEDITIONS || []).find(x => x.id === expeditionId); if (!def) return;
                const currentShare = this.getTotalExpeditionCommitShare();
                if (currentShare + partyShare > 1.0 + 1e-6) { this.uiManager.showModal('Insufficient Forces', '<p>You do not have enough free allies to commit that many to expeditions.</p>'); return; }
                this.state.expeditions.active.push({ id: expeditionId, startedAt: Date.now(), progressMs: 0, partyShare, cyclesCompleted: 0, supply: { foodBuffer: 0, potionBuffer: 0, hungry: false, usingPotions: false } });
                this.uiManager.showFloatingText('Expedition launched!', 'text-green-300');
                this.uiManager.renderView();
            }
            recallExpedition(index) {
                if (!this.state.expeditions?.active?.[index]) return;
                const ex = this.state.expeditions.active[index];
                this.state.expeditions.active.splice(index, 1);
                this.uiManager.showFloatingText('Squad recalled', 'text-yellow-300');
                this.uiManager.renderView();
            }
            processExpeditions(deltaSec) {
                const actives = this.state.expeditions.active || [];
                for (let i = 0; i < actives.length; i++) {
                    const ex = actives[i];
                    const def = (GAME_DATA.EXPEDITIONS || []).find(x => x.id === ex.id); if (!def) continue;
                    // Consume supplies based on party share
                    const foodPerSec = (def.supply?.foodPerMin || 0) * (ex.partyShare || 0) / 60;
                    const potionPerSec = (def.supply?.potionPerMin || 0) * (ex.partyShare || 0) / 60;
                    ex.supply.foodBuffer += foodPerSec * deltaSec;
                    ex.supply.potionBuffer += potionPerSec * deltaSec;
                    // Spend food
                    let needFoodUnits = Math.floor(ex.supply.foodBuffer);
                    if (needFoodUnits > 0) {
                        const foodIds = this.getFoodConsumablesIdsSorted();
                        for (const fid of foodIds) {
                            if (needFoodUnits <= 0) break;
                            const have = this.state.bank[fid] || 0; if (have <= 0) continue;
                            const take = Math.min(have, needFoodUnits);
                            this.removeFromBank(fid, take);
                            needFoodUnits -= take;
                        }
                        ex.supply.foodBuffer -= Math.floor(ex.supply.foodBuffer);
                    }
                    ex.supply.hungry = needFoodUnits > 0;
                    // Spend potions if required (optional boost)
                    let needPotUnits = Math.floor(ex.supply.potionBuffer);
                    let usingPotions = false;
                    if (needPotUnits > 0) {
                        const pid = 'healing_potion';
                        const have = this.state.bank[pid] || 0;
                        if (have > 0) {
                            const take = Math.min(have, needPotUnits);
                            this.removeFromBank(pid, take);
                            needPotUnits -= take; usingPotions = take > 0;
                        }
                        ex.supply.potionBuffer -= Math.floor(ex.supply.potionBuffer);
                    }
                    ex.supply.usingPotions = usingPotions;

                    // Progress and rewards
                    let timePerCycle = def.baseTime;
                    // Party effectiveness: scale time by committed share vs recommended power proxy
                    const baseArmy = this.calculateArmyOutputPerSecond(); // already scaled by availability
                    const totalArmyPower = this.estimateArmyPowerTotal();
                    const partyPower = Math.max(1, totalArmyPower * (ex.partyShare || 0));
                    const recommended = Math.max(1, def.recommendedPower);
                    const speedMult = Math.min(1.5, Math.max(0.5, partyPower / recommended));
                    timePerCycle = timePerCycle / speedMult;
                    if (ex.supply.hungry) timePerCycle *= 1.2;

                    ex.progressMs += deltaSec * 1000;
                    const loops = Math.floor(ex.progressMs / timePerCycle);
                    if (loops > 0) {
                        ex.progressMs %= timePerCycle;
                        ex.cyclesCompleted += loops;
                        // Rewards
                        const hungryPenalty = ex.supply.hungry ? 0.5 : 1.0;
                        const potionBoost = ex.supply.usingPotions ? 1.15 : 1.0;
                        const partyMult = Math.max(0.25, (ex.partyShare || 0));
                        for (let n = 0; n < loops; n++) {
                            const g = this.rollRange(def.gold) * hungryPenalty * potionBoost * partyMult;
                            this.addGold(Math.floor(g));
                            (def.drops || []).forEach(drop => {
                                if (Math.random() * 100 < drop.chance) {
                                    const q = this.rollRange(drop.qty) * partyMult;
                                    if (q >= 1) this.addToBank(drop.id, Math.floor(q));
                                }
                            });
                        }
                        // Flavor
                        this.uiManager.showFloatingText(`${def.emoji} ${def.name}`, 'text-green-300');
                    }
                }
            }
            estimateArmyPowerTotal() {
                // Simple proxy: sum of class (dps + hps*0.8) over owned units
                const units = this.state.army.units || {};
                let power = 0;
                for (const id of Object.keys(GAME_DATA.ARMY_CLASSES)) {
                    const d = GAME_DATA.ARMY_CLASSES[id];
                    const count = units[id] || 0; if (count <= 0) continue;
                    power += (d.dps + d.hps * 0.8) * count;
                }
                return Math.max(1, power);
            }
            rollRange(r) { if (!r) return 0; return Math.floor(Math.random() * (r[1] - r[0] + 1)) + r[0]; }

            getMastery(skillId, actionId) { if (!this.state.player.mastery[skillId][actionId]) { this.state.player.mastery[skillId][actionId] = new Mastery(); } return this.state.player.mastery[skillId][actionId]; }

            gainActionRewards(action, loops) {
                const skill = this.state.player.skills[action.skillId]; skill.addXP(action.xp * loops, this);
                const mastery = this.getMastery(action.skillId, action.id); mastery.addXP(action.baseTime / 1000 * loops);
                if (action.output && action.output.itemId) {
                    this.addToBank(action.output.itemId, action.output.quantity * loops);
                    this.uiManager.showFloatingText(`+${action.output.quantity * loops} ${GAME_DATA.ITEMS[action.output.itemId].name}`, 'text-white');
                }
                if (action.rareDrop) {
                    for (let i = 0; i < loops; i++) {
                        if (Math.random() * 100 < action.rareDrop.chance) {
                            this.addToBank(action.rareDrop.itemId, 1);
                            this.uiManager.showFloatingText(`+1 ${GAME_DATA.ITEMS[action.rareDrop.itemId].name}!`, 'text-yellow-400');
                        }
                    }
                }
            }

            startAction(skillId, actionId) {
                if (this.state.activeAction) return;
                let actionData;
                if (GAME_DATA.ACTIONS[skillId]) actionData = GAME_DATA.ACTIONS[skillId].find(a => a.id === actionId);
                if (GAME_DATA.RECIPES[skillId]) actionData = GAME_DATA.RECIPES[skillId].find(a => a.id === actionId);
                this.state.activeAction = { ...actionData, skillId: skillId, startTime: Date.now(), endTime: null, progress: 0 };
                this.uiManager.render();
            }
            stopAction() {
                if (!this.state.activeAction) return; const action = this.state.activeAction; const actionTime = this.calculateActionTime(action);
                const loops = Math.floor(action.progress / actionTime); if (loops > 0) { this.gainActionRewards(action, loops); }
                this.state.activeAction = null; this.uiManager.render();
            }

            craftItem(skillId, recipeId, quantity) {
                const recipe = GAME_DATA.RECIPES[skillId].find(r => r.id === recipeId); if (!recipe) return;
                const canCraft = recipe.input.every(inp => (this.state.bank[inp.itemId] || 0) >= inp.quantity * quantity); if (!canCraft) return;
                recipe.input.forEach(inp => this.removeFromBank(inp.itemId, inp.quantity * quantity));
                if (recipe.output && recipe.output.itemId) {
                    let totalOut = recipe.output.quantity * quantity;
                    if (skillId === 'runecrafting') {
                        const lvl = this.state.player.skills[skillId].level;
                        const mult = Math.max(1, 1 + Math.floor((lvl - recipe.level) / 11));
                        totalOut *= mult;
                    }
                    this.addToBank(recipe.output.itemId, totalOut);
                    this.uiManager.showFloatingText(`Crafted ${totalOut} ${GAME_DATA.ITEMS[recipe.output.itemId].name}`, 'text-green-400');
                }
                                const skill = this.state.player.skills[skillId]; skill.addXP(recipe.xp * quantity, this);
                // Mastery progress for artisan recipes
                const mastery = this.getMastery(skillId, recipe.id);
                mastery.addXP((recipe.baseTime || 1000) / 1000 * quantity);
                if (skillId === 'firemaking') { this.state.bonfire.active = true; this.state.bonfire.expiry = Date.now() + 2 * 60 * 60 * 1000; this.state.bonfire.xpBoost = 0.05; }
                this.uiManager.renderView();
            }

            // Economy helpers
            addGold(amount) { const final = Math.floor(amount * this.goldMultiplier()); this.state.player.gold += final; }
            spendGold(amount) { if (this.state.player.gold < amount) return false; this.state.player.gold -= amount; return true; }

            // Empire helpers
            calculateEmpireProductionPerSecond() {
                const units = this.state.empire.units || {};
                let goldPerSec = 0, runesPerSec = 0, essencePerSec = 0;
                for (const id of Object.keys(GAME_DATA.UNITS)) {
                    const data = GAME_DATA.UNITS[id];
                    const count = units[id] || 0;
                    if (count <= 0) continue;
                    if (data.goldPerSec) goldPerSec += data.goldPerSec * count;
                    if (data.runesPerSec) runesPerSec += data.runesPerSec * count;
                    if (data.essencePerSec) essencePerSec += data.essencePerSec * count;
                }
                // Gold is multiplied later via addGold; show base before buff for UI but store base here
                return { goldPerSec, runesPerSec, essencePerSec };
            }
            getEmpireUnitCost(id) {
                const data = GAME_DATA.UNITS[id];
                const owned = this.state.empire.units[id] || 0;
                return Math.floor(data.baseCost * Math.pow(data.costGrowth, owned));
            }
            hireEmpireUnit(id) {
                const cost = this.getEmpireUnitCost(id);
                if (!this.spendGold(cost)) { this.uiManager.showModal('Insufficient Gold', `<p>You need ${cost} gold to hire a ${GAME_DATA.UNITS[id].name}.</p>`); return; }
                this.state.empire.units[id] = (this.state.empire.units[id] || 0) + 1;
                this.uiManager.showFloatingText(`+1 ${GAME_DATA.UNITS[id].name}`, 'text-yellow-300');
                this.uiManager.renderView();
            }

            // Worker economy
            getHireCost(skillId) {
                const ws = this.state.workers?.[skillId]; if (!ws) return Infinity;
                const base = 150; // same base for now across skills
                const owned = ws.total || 0;
                return Math.floor(base * Math.pow(1.35, owned));
            }
            getUpgradeCost(skillId, type) {
                const ws = this.state.workers?.[skillId]; if (!ws) return Infinity;
                const base = type === 'speed' ? 250 : 300;
                const level = type === 'speed' ? (ws.upgrades.speedLevel || 0) : (ws.upgrades.yieldLevel || 0);
                return Math.floor(base * Math.pow(1.55, level));
            }
            hireWorker(skillId) {
                const ws = this.state.workers?.[skillId]; if (!ws) return;
                const cost = this.getHireCost(skillId);
                if (!this.spendGold(cost)) { this.uiManager.showModal('Not Enough Gold', `<p>You need ${cost} gold to hire a worker.</p>`); return; }
                ws.total += 1;
                const name = skillId === 'woodcutting' ? 'Timberhand' : (skillId === 'mining' ? 'Miner' : 'Worker');
                                 this.uiManager.showFloatingText(`+1 ${name} Hired`, 'text-green-400'); this.uiManager.renderView();
                this.uiManager.renderView();
            }
            upgradeWorkers(skillId, type) {
                const ws = this.state.workers?.[skillId]; if (!ws) return;
                const cost = this.getUpgradeCost(skillId, type);
                if (!this.spendGold(cost)) { this.uiManager.showModal('Not Enough Gold', `<p>You need ${cost} gold to upgrade.</p>`); return; }
                if (type === 'speed') ws.upgrades.speedLevel += 1;
                if (type === 'yield') ws.upgrades.yieldLevel += 1;
                const place = skillId === 'woodcutting' ? 'Timber Lodge' : (skillId === 'mining' ? 'Mining Camp' : 'Workshop');
                this.uiManager.showFloatingText(`${place} Upgraded!`, 'text-yellow-300');
                this.uiManager.renderView();
            }

            addToBank(itemId, quantity) { this.state.bank[itemId] = (this.state.bank[itemId] || 0) + quantity; }
            removeFromBank(itemId, quantity) { this.state.bank[itemId] -= quantity; if (this.state.bank[itemId] <= 0) { delete this.state.bank[itemId]; } }

            // Rune helpers
            getRuneItemIds() { return Object.keys(GAME_DATA.ITEMS).filter(id => id.endsWith('_rune')); }
            getTotalRuneItemCount() { return this.getRuneItemIds().reduce((sum, id) => sum + (this.state.bank[id] || 0), 0); }
            consumeRuneItems(amount) {
                let remaining = amount;
                const ids = this.getRuneItemIds();
                for (const id of ids) {
                    const have = this.state.bank[id] || 0; if (have <= 0) continue;
                    const take = Math.min(have, remaining);
                    this.removeFromBank(id, take);
                    remaining -= take;
                    if (remaining <= 0) break;
                }
            }

            // Real-life task completion -> stamina + meta XP
            completeRealLifeTask(metaSkillCategory, difficulty) {
                const difficultyMultipliers = { small: 1, medium: 1.5, large: 2.5 }; const multiplier = difficultyMultipliers[difficulty];
                const staminaGained = Math.floor(10 * multiplier); this.state.player.stamina = Math.min(this.state.player.staminaMax, this.state.player.stamina + staminaGained); this.uiManager.showFloatingText(`+${staminaGained} Stamina`, 'text-green-400');
                const xpGained = Math.floor(20 * multiplier); const metaSkill = this.state.player.meta_skills[metaSkillCategory]; if (metaSkill) { metaSkill.addXP(xpGained, this); }
                this.uiManager.render();
            }

            // Spells
            castSpell(spellId) {
                const spell = GAME_DATA.SPELLS.find(s => s.id === spellId); if (!spell) return;
                const availableRunes = this.state.player.runes + this.getTotalRuneItemCount();
                if (availableRunes < spell.runeCost) { this.uiManager.showModal('Not Enough Runes', '<p>You lack the runes to cast this spell.</p>'); return; }
                // Spend generic runes first, then consume crafted rune items from bank
                const spendFromGeneric = Math.min(this.state.player.runes, spell.runeCost);
                this.state.player.runes -= spendFromGeneric;
                const remaining = spell.runeCost - spendFromGeneric;
                if (remaining > 0) this.consumeRuneItems(remaining);
                this.state.player.activeBuffs[spell.effect] = Date.now() + spell.durationMs;
                this.uiManager.showFloatingText(`${spell.name} activated!`, 'text-purple-300');
                this.uiManager.renderView();
            }

            // Chests
            buyChest(chestId) {
                const chest = GAME_DATA.CHESTS.find(c => c.id === chestId); if (!chest) return;
                if (chest.keyItemID && !(this.state.bank[chest.keyItemID] > 0)) { this.uiManager.showModal('Locked Chest', '<p>You need a special key to open this chest.</p>'); return; }
                const price = chest.cost; if (price > 0 && !this.spendGold(price)) { this.uiManager.showModal('Not Enough Gold', '<p>You cannot afford this chest.</p>'); return; }
                if (chest.keyItemID) this.removeFromBank(chest.keyItemID, 1);
                const [minR, maxR] = chest.rewardCount; const rolls = Math.floor(Math.random() * (maxR - minR + 1)) + minR;
                const rewards = [];
                for (let i = 0; i < rolls; i++) {
                    const pick = chest.lootTable[Math.floor(Math.random() * chest.lootTable.length)];
                    if (pick.type === 'currency') { const amt = pick.amount; this.addGold(amt); rewards.push(`+${amt} Gold`); }
                    if (pick.type === 'item') { const q = Array.isArray(pick.qty) ? (Math.floor(Math.random() * (pick.qty[1] - pick.qty[0] + 1)) + pick.qty[0]) : (pick.qty || 1); this.addToBank(pick.id, q); rewards.push(`+${q} ${GAME_DATA.ITEMS[pick.id]?.name || pick.id}`); }
                    if (pick.type === 'runes') { const amt = pick.amount; this.state.player.runes += amt; rewards.push(`+${amt} Runes`); }
                }
                this.uiManager.showModal('Chest Opened!', `<div class="space-y-1">${rewards.map(r => `<p>${r}</p>`).join('')}</div>`);
                this.uiManager.renderView();
            }

            // Combat
            startCombat(enemyId) {
                if (this.state.combat.inCombat) return; const e = JSON.parse(JSON.stringify(GAME_DATA.COMBAT.ENEMIES.find(x => x.id === enemyId))); if (!e) return;
                this.state.combat.inCombat = true; this.state.combat.enemy = e; this.state.player.hp = Math.min(this.state.player.hp, this.state.player.hpMax);
                this.state.combat.lastPlayerAttack = 0; this.state.combat.lastEnemyAttack = 0; this.uiManager.renderView();
            }
            endCombat(victory) {
                if (!this.state.combat.inCombat) return; if (!victory) { this.uiManager.showModal('Defeated', '<p>You were defeated. Rest to recover HP.</p>'); }
                this.state.combat.inCombat = false; this.state.combat.enemy = null; this.uiManager.renderView();
            }
            handleEnemyDefeat(enemy) {
                // Gold
                const g = Math.floor(Math.random() * (enemy.gold[1] - enemy.gold[0] + 1)) + enemy.gold[0]; this.addGold(g);
                // Drops
                (enemy.drops || []).forEach(drop => { if (Math.random() * 100 < drop.chance) { const q = Math.floor(Math.random() * (drop.qty[1] - drop.qty[0] + 1)) + drop.qty[0]; this.addToBank(drop.id, q); } });
                // XP to Strength
                this.state.player.meta_skills[META_SKILLS.STRENGTH].addXP(15 + enemy.level * 2, this);
                this.uiManager.showFloatingText(`${enemy.name} defeated!`, 'text-green-400');
                this.endCombat(true);
            }
            calculatePlayerDamage(enemy) {
                let base = 5; if (this.state.player.weapon && GAME_DATA.ITEMS[this.state.player.weapon]?.damage) base += GAME_DATA.ITEMS[this.state.player.weapon].damage;
                const strBonus = 1 + (this.state.player.meta_skills[META_SKILLS.STRENGTH].level - 1) * 0.03; const dmg = Math.max(1, Math.floor((base * strBonus) - enemy.defense * 0.5));
                return dmg;
            }
            eatFood(itemId) {
                const item = GAME_DATA.ITEMS[itemId]; if (!item || !item.heals) return; if ((this.state.bank[itemId] || 0) <= 0) return;
                this.removeFromBank(itemId, 1); this.state.player.hp = Math.min(this.state.player.hpMax, this.state.player.hp + item.heals); this.uiManager.showFloatingText(`+${item.heals} HP`, 'text-green-300'); this.uiManager.renderView();
            }
            equipWeapon(itemId) { if (!GAME_DATA.ITEMS[itemId]) return; if ((this.state.bank[itemId] || 0) <= 0) return; this.state.player.weapon = itemId; this.uiManager.renderView(); }

            saveGame() { try { localStorage.setItem('chimeraSaveData_web_v1', JSON.stringify(this.state)); } catch (e) { console.error('Failed to save game:', e); } }
            loadGame() {
                const savedData = localStorage.getItem('chimeraSaveData_web_v1');
                if (savedData) {
                    try {
                        const parsedData = JSON.parse(savedData);
                        Object.assign(this.state, parsedData);
                        // Rehydrate skill objects
                        Object.keys(GAME_DATA.SKILLS).forEach(id => { const skill = new Skill(id, GAME_DATA.SKILLS[id].name); if (parsedData.player.skills?.[id]) Object.assign(skill, parsedData.player.skills[id]); this.state.player.skills[id] = skill; });
                        Object.values(META_SKILLS).forEach(name => { const skill = new Skill(name, name); if (parsedData.player.meta_skills?.[name]) Object.assign(skill, parsedData.player.meta_skills[name]); this.state.player.meta_skills[name] = skill; });
                        // Rehydrate mastery
                        Object.keys(parsedData.player.mastery || {}).forEach(skillId => {
                            if (!this.state.player.mastery[skillId]) this.state.player.mastery[skillId] = {};
                            Object.keys(parsedData.player.mastery[skillId]).forEach(actionId => { const mastery = new Mastery(); Object.assign(mastery, parsedData.player.mastery[skillId][actionId]); this.state.player.mastery[skillId][actionId] = mastery; });
                        });
                        this.state.lastUpdate = Date.now();
                        // Backfill worker system defaults if missing (woodcutting, mining)
                        if (!this.state.workers) {
                            this.state.workers = {
                                woodcutting: { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} },
                                mining: { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} }
                            };
                        }
                        if (!this.state.workers.woodcutting) { this.state.workers.woodcutting = { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} }; }
                        if (!this.state.workers.mining) { this.state.workers.mining = { total: 0, upgrades: { speedLevel: 0, yieldLevel: 0 }, assigned: {}, progress: {} }; }
                        (GAME_DATA.ACTIONS.woodcutting || []).forEach(a => {
                            if (typeof this.state.workers.woodcutting.assigned[a.id] !== 'number') this.state.workers.woodcutting.assigned[a.id] = 0;
                            if (typeof this.state.workers.woodcutting.progress[a.id] !== 'number') this.state.workers.woodcutting.progress[a.id] = 0;
                        });
                        (GAME_DATA.ACTIONS.mining || []).forEach(a => {
                            if (typeof this.state.workers.mining.assigned[a.id] !== 'number') this.state.workers.mining.assigned[a.id] = 0;
                            if (typeof this.state.workers.mining.progress[a.id] !== 'number') this.state.workers.mining.progress[a.id] = 0;
                        });
                         // Backfill empire system defaults if missing
                         if (!this.state.empire) { this.state.empire = { units: {}, lastTick: Date.now(), production: { goldPerSec: 0, runesPerSec: 0, essencePerSec: 0 }, buffers: { gold: 0, runes: 0, essence: 0 } }; }
                        if (!this.state.empire.units) this.state.empire.units = {};
                        Object.keys(GAME_DATA.UNITS).forEach(id => { if (typeof this.state.empire.units[id] !== 'number') this.state.empire.units[id] = 0; });
                        // Backfill army system defaults if missing
                        if (!this.state.army) { this.state.army = { units: {}, lastTick: Date.now(), production: { dps: 0, hps: 0, hungry: false }, upkeep: { foodBuffer: 0, hungry: false }, fly: { accumDmg: 0, accumHeal: 0, lastFlush: Date.now() } }; }
                        if (!this.state.army.units) this.state.army.units = {};
                        Object.keys(GAME_DATA.ARMY_CLASSES).forEach(id => { if (typeof this.state.army.units[id] !== 'number') this.state.army.units[id] = 0; });
                        if (!this.state.army.production) this.state.army.production = { dps: 0, hps: 0, hungry: false };
                        if (!this.state.army.upkeep) this.state.army.upkeep = { foodBuffer: 0, hungry: false };
                        if (!this.state.army.fly) this.state.army.fly = { accumDmg: 0, accumHeal: 0, lastFlush: Date.now() };
                        if (!this.state.army.lastTick) this.state.army.lastTick = Date.now();
                        // Backfill expeditions defaults
                        if (!this.state.expeditions) this.state.expeditions = { active: [], lastTick: Date.now() };
                        if (!Array.isArray(this.state.expeditions.active)) this.state.expeditions.active = [];
                        if (!this.state.expeditions.lastTick) this.state.expeditions.lastTick = Date.now();
                     } catch (e) { console.error('Failed to load game, starting new.', e); this.state = new GameState(); }
                }
            }
            resetSave() {
                try { localStorage.removeItem('chimeraSaveData_web_v1'); } catch (e) { console.error('Failed to clear save:', e); }
                this.state = new GameState();
                this.uiManager.showFloatingText('Save reset', 'text-red-300');
                this.uiManager.render();
            }

            // Army helpers
            getArmyUnitCost(id) {
                const data = GAME_DATA.ARMY_CLASSES[id];
                const owned = this.state.army.units[id] || 0;
                return Math.floor(data.baseCost * Math.pow(data.costGrowth, owned));
            }
            hireArmyUnit(id) {
                const cost = this.getArmyUnitCost(id);
                if (!this.spendGold(cost)) { this.uiManager.showModal('Insufficient Gold', `<p>You need ${cost} gold to hire a ${GAME_DATA.ARMY_CLASSES[id].name}.</p>`); return; }
                this.state.army.units[id] = (this.state.army.units[id] || 0) + 1;
                this.uiManager.showFloatingText(`+1 ${GAME_DATA.ARMY_CLASSES[id].name}`, 'text-green-300');
                this.uiManager.renderView();
            }
            calculateArmyOutputPerSecond() {
                const units = this.state.army.units || {};
                let dps = 0, hps = 0, foodPerMin = 0;
                for (const id of Object.keys(GAME_DATA.ARMY_CLASSES)) {
                    const def = GAME_DATA.ARMY_CLASSES[id];
                    const count = units[id] || 0;
                    if (count <= 0) continue;
                    if (def.dps) dps += def.dps * count;
                    if (def.hps) hps += def.hps * count;
                    if (def.foodPerMin) foodPerMin += def.foodPerMin * count;
                }
                // Scale down army availability by expeditions committed share for combat contribution and upkeep here
                const committedShare = this.getTotalExpeditionCommitShare();
                const availableFrac = Math.max(0, 1 - committedShare);
                return { dps: dps * availableFrac, hps: hps * availableFrac, foodPerMin: foodPerMin * availableFrac };
            }
            consumeArmyUpkeep(deltaSec) {
                const foodIds = Object.keys(this.state.bank).filter(id => GAME_DATA.ITEMS[id]?.heals).sort((a,b) => (GAME_DATA.ITEMS[a].heals||0)-(GAME_DATA.ITEMS[b].heals||0));
                const out = this.calculateArmyOutputPerSecond();
                const requiredFoodUnits = (out.foodPerMin / 60) * deltaSec; // food units per sec
                this.state.army.upkeep.foodBuffer += requiredFoodUnits;
                let needed = Math.floor(this.state.army.upkeep.foodBuffer);
                if (needed > 0) {
                    for (const fid of foodIds) {
                        if (needed <= 0) break;
                        const have = this.state.bank[fid] || 0; if (have <= 0) continue;
                        const take = Math.min(have, needed);
                        this.removeFromBank(fid, take);
                        needed -= take;
                    }
                    this.state.army.upkeep.foodBuffer -= Math.floor(this.state.army.upkeep.foodBuffer);
                }
                const hungry = needed > 0; // unmet demand
                this.state.army.upkeep.hungry = hungry;
                return { hungry, out };
            }
            rallyArmy() {
                if (this.hasBuff('armyRally')) { this.uiManager.showModal('Rally Active', '<p>Your allies are already rallied!</p>'); return; }
                if ((this.state.player.runes || 0) < 1) { this.uiManager.showModal('Not Enough Runes', '<p>You need 1 rune to blow the rally horn.</p>'); return; }
                this.state.player.runes -= 1;
                this.state.player.activeBuffs['armyRally'] = Date.now() + (20 * 1000);
                this.uiManager.showFloatingText('Rally!', 'text-yellow-300');
                this.uiManager.renderView();
            }
        }

        class UIManager {
            constructor(game) { this.game = game; this.currentView = 'dashboard'; }
            init() { this.renderSidebar(); this.attachSidebarEventListeners(); this.render(); }
            renderSidebar() {
                const createLink = (id, s) => `<a href="#" class="sidebar-link flex items-center p-3" data-view="${id}"><i class="fas ${s.icon} w-6 text-center"></i><span>${s.name}</span><div class="w-16 ml-auto h-1 bg-black/30 rounded-full overflow-hidden ml-2"><div id="sidebar-xp-${id}" class="xp-bar-fill h-1" style="width:0%"></div></div></a>`;
                const gatheringHtml = Object.keys(GAME_DATA.SKILLS).filter(id => GAME_DATA.SKILLS[id].type === 'gathering').map(id => createLink(id, GAME_DATA.SKILLS[id])).join(''); document.getElementById('gathering-skills-nav').innerHTML = gatheringHtml;
                const artisanHtml = Object.keys(GAME_DATA.SKILLS).filter(id => GAME_DATA.SKILLS[id].type === 'artisan').map(id => createLink(id, GAME_DATA.SKILLS[id])).join(''); document.getElementById('artisan-skills-nav').innerHTML = artisanHtml;
            }
            attachSidebarEventListeners() { document.querySelectorAll('.sidebar-link').forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); this.currentView = link.dataset.view; this.render(); }); }); }
            render() { this.updateSidebarActive(); this.renderView(); }

            updateDynamicElements() {
                const goldEl = document.getElementById('gold-display'); if (goldEl) goldEl.textContent = Math.floor(this.game.state.player.gold).toLocaleString();
                const runesEl = document.getElementById('runes-display'); if (runesEl) { const totalRunes = (this.game.state.player.runes || 0) + this.game.getTotalRuneItemCount(); runesEl.textContent = totalRunes.toLocaleString(); }
                const stamina = this.game.state.player.stamina; const staminaMax = this.game.state.player.staminaMax;
                                 document.getElementById('stamina-value').textContent = `${Math.floor(stamina)}/${staminaMax}`; document.getElementById('stamina-bar-fill').style.width = `${(stamina / staminaMax) * 100}%`;
                 // If in combat, show Ally badge refresh
                 if (this.currentView === 'combat') this.renderCombatFooter();
                Object.keys(this.game.state.player.skills).forEach(id => { const skill = this.game.state.player.skills[id]; const xpBar = document.getElementById(`sidebar-xp-${id}`); if (xpBar) xpBar.style.width = `${(skill.currentXP / skill.xpToNextLevel) * 100}%`; });
                this.updateMasteryBar();
                // If in combat, update view footer elements
                if (this.currentView === 'combat') this.renderCombatFooter();
            }
            updateSidebarActive() { document.querySelectorAll('.sidebar-link').forEach(link => { link.classList.toggle('active', link.dataset.view === this.currentView); }); }

            updateMasteryBar() {
                const container = document.getElementById('mastery-progress-bar'); const action = this.game.state.activeAction; const inCombat = this.game.state.combat.inCombat; if (!action && !inCombat) { container.innerHTML = ''; return; }
                if (inCombat) {
                    const e = this.game.state.combat.enemy; if (!e) { container.innerHTML = ''; return; }
                    const playerHpPct = (this.game.state.player.hp / this.game.state.player.hpMax) * 100;
                    const enemyHpPct = (e.hp / e.maxHp) * 100;
                    container.innerHTML = `<div class="block p-2 h-full grid grid-cols-2 gap-2 items-center">
                        <div>
                            <div class="w-full bg-black/40 rounded-full h-3 overflow-hidden border border-border-color">
                                <div class="bg-green-500 h-3" style="width:${playerHpPct}%"></div>
                            </div>
                            <p class="text-xs text-secondary mt-1">You</p>
                        </div>
                        <div>
                            <div class="w-full bg-black/40 rounded-full h-3 overflow-hidden border border-border-color">
                                <div class="bg-red-500 h-3" style="width:${enemyHpPct}%"></div>
                            </div>
                            <p class="text-xs text-secondary mt-1">${e.name}</p>
                        </div>
                    </div>`;
                } else {
                    const act = action; const pct = (act.progress / this.game.calculateActionTime(act)) * 100;
                    container.innerHTML = `<div class="block p-2 h-full">
                        <div class="w-full xp-bar-bg rounded-full h-3 overflow-hidden border border-border-color">
                            <div class="mastery-bar-fill h-3" style="width:${pct}%"></div>
                        </div>
                        <p class="text-xs text-secondary mt-1">${act.name}</p>
                    </div>`;
                }
            }

            renderView() {
                let html = '';
                switch (this.currentView) {
                    case 'dashboard': html = this.renderDashboardView(); break;
                    case 'bank': html = this.renderBankView(); break;
                    case 'meta_skills': html = this.renderMetaSkillsView(); break;
                                             case 'combat': html = this.renderCombatView(); break;
                     case 'army': html = this.renderArmyView(); break;
                    case 'clicker': html = this.renderClickerView(); break;
                    case 'spellbook': html = this.renderSpellbookView(); break;
                    case 'shop': html = this.renderShopView(); break;
                    default:
                        if (GAME_DATA.SKILLS[this.currentView]) html = this.renderSkillView(this.currentView);
                        else html = '<p class="text-secondary">Coming soon.</p>';
                }
                document.getElementById('main-content').innerHTML = html;
                this.attachViewEventListeners();
            }

            // ... existing code ...

            renderCombatView() {
                const eList = GAME_DATA.COMBAT.ENEMIES.map(e => `<button class="start-combat-btn chimera-button px-3 py-2 rounded-md" data-enemy-id="${e.id}"><i class="fas fa-skull"></i> ${e.name} (Lv ${e.level})</button>`).join(' ');
                const equipped = this.game.state.player.weapon ? GAME_DATA.ITEMS[this.game.state.player.weapon].name : 'None';
                const foodList = Object.entries(this.game.state.bank).filter(([id, q]) => GAME_DATA.ITEMS[id]?.heals).map(([id, q]) => `<button class="eat-food-btn chimera-button px-2 py-1 rounded-md" data-item-id="${id}">${GAME_DATA.ITEMS[id].name} x${q}</button>`).join(' ');
                const weapons = Object.entries(this.game.state.bank).filter(([id, q]) => GAME_DATA.ITEMS[id]?.damage).map(([id, q]) => `<button class="equip-weapon-btn chimera-button px-2 py-1 rounded-md" data-item-id="${id}">${GAME_DATA.ITEMS[id].name}</button>`).join(' ');
                const combatStatus = this.game.state.combat.inCombat && this.game.state.combat.enemy ? `<p class="text-secondary">Fighting: <span class="text-white font-bold">${this.game.state.combat.enemy.name}</span></p>` : '<p class="text-secondary">Not in combat.</p>';
                // Expeditions cards
                const expDefs = GAME_DATA.EXPEDITIONS || [];
                const cards = expDefs.map(d => {
                    const shareBtns = [0.25, 0.5, 1.0].map(s => `<button class="launch-expedition-btn chimera-button px-2 py-1 rounded" data-exp-id="${d.id}" data-share="${s}">${Math.round(s*100)}%</button>`).join(' ');
                    return `
                        <div class="expedition-card">
                            <div class="flex items-center justify-between">
                                <h3 class="text-white font-semibold">${d.emoji} ${d.name}</h3>
                                <span class="badge"><i class="fas fa-skull"></i> Lv ${d.level}</span>
                            </div>
                            <p class="text-xs text-secondary">Recommended Power: ${d.recommendedPower} • Cycle: ${(d.baseTime/1000).toFixed(0)}s</p>
                            <div class="flex items-center gap-2 text-xs text-secondary">
                                <span class="badge"><i class="fas fa-bread-slice"></i> ${d.supply.foodPerMin.toFixed(1)} food/min</span>
                                ${d.supply.potionPerMin ? `<span class="badge"><i class="fas fa-flask"></i> ${d.supply.potionPerMin.toFixed(1)} pot/min</span>` : ''}
                            </div>
                            <div class="mt-2 flex items-center gap-2">${shareBtns}</div>
                        </div>
                    `;
                }).join('');
                const active = (this.game.state.expeditions?.active || []).map((ex, idx) => {
                    const d = (GAME_DATA.EXPEDITIONS || []).find(x => x.id === ex.id); if (!d) return '';
                    const pct = ((ex.progressMs % d.baseTime) / d.baseTime) * 100;
                    const hungry = ex.supply?.hungry ? '<span class="text-red-400 ml-1">Hungry</span>' : '';
                    const pot = ex.supply?.usingPotions ? '<span class="text-green-400 ml-1">Potions</span>' : '';
                    return `
                        <div class="expedition-card expedition-active">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center gap-2"><span>${d.emoji}</span><h3 class="text-white font-semibold">${d.name}</h3></div>
                                <span class="badge"><i class="fas fa-users"></i> ${Math.round((ex.partyShare||0)*100)}% committed</span>
                            </div>
                            <div class="w-full bg-black/40 rounded-full h-2 overflow-hidden border border-border-color mt-2">
                                <div class="bg-green-500 h-2" style="width:${pct}%"></div>
                            </div>
                            <p class="text-xs text-secondary mt-1">Cycles: <span class="text-white font-mono">${ex.cyclesCompleted}</span> ${hungry} ${pot}</p>
                            <div class="mt-2"><button class="recall-expedition-btn chimera-button px-2 py-1 rounded" data-ex-index="${idx}"><i class="fas fa-flag"></i> Recall</button></div>
                        </div>
                    `;
                }).join('') || '<p class="text-secondary">No active expeditions.</p>';
                const committed = Math.round(this.game.getTotalExpeditionCommitShare()*100);
                return `
                    <h1 class="text-2xl font-semibold text-white mb-4">Combat</h1>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                        <div class="block p-4 space-y-3">
                            <h2 class="text-lg font-bold">Enemies</h2>
                            <div class="space-x-2">${eList}</div>
                        </div>
                                                 <div class="block p-4 space-y-2">
                             <h2 class="text-lg font-bold">Status</h2>
                             ${combatStatus}
                             <p class="text-secondary">HP: <span class="font-mono">${Math.floor(this.game.state.player.hp)}/${this.game.state.player.hpMax}</span></p>
                             <div class="mt-2">
                                 <span class="badge"><i class="fas fa-users"></i> Allies: DPS ${Math.max(0,(this.game.state.army.production?.dps||0)).toFixed(1)} • HPS ${Math.max(0,(this.game.state.army.production?.hps||0)).toFixed(1)} ${this.game.state.army.upkeep?.hungry ? '<span class="text-red-400 ml-1">Hungry</span>' : ''}</span>
                                 <div class="text-xs text-secondary mt-1">Expeditions committed: <span class="text-white">${committed}%</span></div>
                             </div>
                             <button id="end-combat-btn" class="chimera-button px-3 py-2 rounded-md" ${this.game.state.combat.inCombat ? '' : 'disabled'}>Retreat</button>
                         </div>
                        <div class="block p-4 space-y-3">
                            <h2 class="text-lg font-bold">Equipment & Food</h2>
                            <p class="text-secondary">Weapon: <span class="text-white">${equipped}</span></p>
                            <div class="space-x-2">${weapons || '<span class="text-secondary">Craft a weapon in Smithing.</span>'}</div>
                            <div class="space-x-2">${foodList || '<span class="text-secondary">Cook food to heal.</span>'}</div>
                        </div>
                    </div>
                    <div class="mt-6 expedition-hero p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
                        <div class="lg:col-span-2">
                            <h2 class="text-lg font-bold mb-2">Bounties & Expeditions</h2>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">${cards}</div>
                        </div>
                        <div class="lg:col-span-1">
                            <h2 class="text-lg font-bold mb-2">Active Squads</h2>
                            <div class="space-y-3">${active}</div>
                        </div>
                    </div>
                `;
            }
            renderCombatFooter() { /* placeholder for potential dynamic footer updates */ }

            showModal(title, content) {
                const backdrop = document.getElementById('modal-backdrop');
                const modal = document.getElementById('modal-content');
                const html = `<h3 class=\"text-xl font-bold text-white\">${title}</h3><div class=\"text-secondary my-4\">${content}</div><div class=\"text-right mt-6\"><button class=\"close-btn chimera-button px-4 py-2 rounded-md\">Close</button></div>`;
                modal.innerHTML = html; modal.querySelector('.close-btn').addEventListener('click', () => this.hideModal()); backdrop.classList.remove('hidden');
            }
            hideModal() { const backdrop = document.getElementById('modal-backdrop'); if (backdrop) backdrop.classList.add('hidden'); }
            showFloatingText(text, className, options = {}) {
                const container = document.getElementById('floating-text-container'); if (!container) return;
                if (!this._fly) { this._fly = { nextLane: 0, maxLanes: 12, laneHeight: 28 }; }
                const lower = (text || '').toLowerCase();
                let typeClass = '';
                if (lower.includes('level up')) typeClass = 'fly-level';
                else if (lower.includes('activated')) typeClass = 'fly-buff';
                else if (lower.includes('stamina') || lower.includes('hp') || (className||'').includes('green')) typeClass = 'fly-heal';
                else if ((text||'').startsWith('-') || (className||'').includes('red')) typeClass = 'fly-damage';
                else if (lower.includes('crafted') || lower.includes('+1 ') || (className||'').includes('yellow')) typeClass = 'fly-loot';
                else if (lower.includes('xp')) typeClass = 'fly-xp';
                const el = document.createElement('div');
                el.className = `floating-text ${typeClass} ${className || ''}`.trim();
                el.textContent = text;
                const rect = container.getBoundingClientRect();
                const baseX = rect.width / 2; const baseY = rect.height / 3;
                const lane = this._fly.nextLane; this._fly.nextLane = (this._fly.nextLane + 1) % this._fly.maxLanes;
                const jitterX = (Math.random() - 0.5) * 80; const y = baseY - lane * this._fly.laneHeight;
                el.style.left = `${baseX + jitterX}px`; el.style.top = `${y}px`;
                container.appendChild(el);
                const duration = typeClass === 'fly-crit' || typeClass === 'fly-level' ? 1900 : (typeClass === 'fly-loot' ? 1800 : 1600);
                setTimeout(() => el.remove(), duration);
            }

            renderClickerView() {
                const units = GAME_DATA.UNITS;
                const owned = this.game.state.empire.units;
                const prod = this.game.calculateEmpireProductionPerSecond();
                const cards = Object.keys(units).map(id => {
                    const u = units[id];
                    const qty = owned[id] || 0;
                    const cost = this.game.getEmpireUnitCost(id);
                    const lines = [];
                    if (u.goldPerSec) lines.push(`Gold: +${u.goldPerSec}/s each`);
                    if (u.runesPerSec) lines.push(`Runes: +${u.runesPerSec}/s each`);
                    if (u.essencePerSec) lines.push(`Essence: +${u.essencePerSec}/s each`);
                    return `
                        <div class="block p-4 flex flex-col justify-between">
                            <div>
                                <h3 class="text-lg font-bold">${u.emoji} ${u.name}</h3>
                                <p class="text-secondary text-xs">${u.description}</p>
                                <p class="text-secondary text-xs mt-1">${lines.join(' • ')}</p>
                                <p class="text-white text-sm mt-2">Owned: <span class="font-mono">${qty}</span></p>
                            </div>
                            <button class="hire-unit-btn chimera-button px-3 py-2 rounded-md mt-3" data-unit-id="${id}">Hire — Cost: ${cost} gold</button>
                        </div>
                    `;
                }).join('');
                return `
                    <h1 class="text-2xl font-semibold text-white mb-4">Empire Command</h1>
                    <div class="block p-4 mb-4">
                        <h2 class="text-lg font-bold">Production</h2>
                        <p class="text-secondary text-sm">Gold: <span class="text-white">+${prod.goldPerSec.toFixed(1)}/s</span> • Runes: <span class="text-white">+${(prod.runesPerSec||0).toFixed(2)}/s</span> • Essence: <span class="text-white">+${(prod.essencePerSec||0).toFixed(2)}/s</span></p>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${cards}</div>
                `;
            }

            renderSpellbookView() {
                const buffs = this.game.state.player.activeBuffs || {};
                const cards = GAME_DATA.SPELLS.map(s => {
                    const active = buffs[s.effect] && Date.now() < buffs[s.effect];
                    const remaining = active ? Math.ceil((buffs[s.effect] - Date.now()) / 1000) : 0;
                    return `
                        <div class="block p-4 flex flex-col justify-between ${active ? 'ring-1 ring-purple-400' : ''}">
                            <div>
                                <h3 class="text-lg font-bold">${s.name}</h3>
                                <p class="text-secondary text-xs">${s.description}</p>
                                <p class="text-secondary text-xs">Rune Cost: ${s.runeCost}</p>
                                ${active ? `<p class="text-xs text-purple-300">${remaining}s remaining</p>` : ''}
                            </div>
                            <button class="cast-spell-btn chimera-button px-3 py-2 rounded-md mt-3" data-spell-id="${s.id}" ${active ? 'disabled' : ''}>Cast</button>
                        </div>
                    `;
                }).join('');
                return `
                    <h1 class="text-2xl font-semibold text-white mb-4">Spellbook</h1>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${cards}</div>
                `;
            }

            // Minimal generic views to keep other tabs functional
            renderDashboardView() {
                const prod = this.game.state.empire?.production || { goldPerSec: 0, runesPerSec: 0, essencePerSec: 0 };
                return `
                    <div class="block p-6 mb-4 bg-gradient-to-r from-black/40 to-black/20 border border-border-color">
                        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
                            <div class="flex items-center gap-3">
                                <i class="fas fa-crown text-yellow-400 text-2xl"></i>
                                <div>
                                    <h1 class="text-2xl font-semibold text-white">The Sovereign's Ledger</h1>
                                    <p class="text-secondary">Command your medieval economy and rise to legend.</p>
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button id="goto-empire" class="chimera-button px-3 py-2 rounded-md"><i class="fas fa-chess-rook"></i> Empire</button>
                                <button id="goto-woodcutting" class="chimera-button px-3 py-2 rounded-md"><i class="fas fa-tree"></i> Woodcutting</button>
                                <button id="goto-runecrafting" class="chimera-button px-3 py-2 rounded-md"><i class="fas fa-circle-nodes"></i> Runecrafting</button>
                                <button id="goto-combat" class="chimera-button px-3 py-2 rounded-md"><i class="fas fa-skull"></i> Combat</button>
                                <button id="goto-shop" class="chimera-button px-3 py-2 rounded-md"><i class="fas fa-store"></i> Shop</button>
                                <button id="reset-save" class="chimera-button px-3 py-2 rounded-md"><i class="fas fa-trash"></i> Reset Save</button>
                            </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="block p-4"><h2 class="text-lg font-bold">Treasury</h2><p class="text-secondary">Gold on hand</p><p class="text-2xl font-mono text-yellow-300">${Math.floor(this.game.state.player.gold).toLocaleString()}</p><p class="text-xs text-green-300 mt-1">+${(prod.goldPerSec||0).toFixed(1)}/s</p></div>
                        <div class="block p-4"><h2 class="text-lg font-bold">Arcane Reserves</h2><p class="text-secondary">Runes & Essence</p><p class="text-2xl font-mono text-purple-300">${((this.game.state.player.runes||0) + this.game.getTotalRuneItemCount()).toLocaleString()}</p><p class="text-xs text-blue-300 mt-1">Runes: +${(prod.runesPerSec||0).toFixed(2)}/s • Essence: +${(prod.essencePerSec||0).toFixed(2)}/s</p></div>
                        <div class="block p-4"><h2 class="text-lg font-bold">Stamina</h2><p class="text-secondary">Stay energized for adventure</p><p class="text-2xl font-mono text-green-300">${Math.floor(this.game.state.player.stamina)}/${this.game.state.player.staminaMax}</p></div>
                    </div>
                `;
            }
            renderBankView() {
                let itemsHtml = Object.entries(this.game.state.bank).map(([itemId, quantity]) => { const itemData = GAME_DATA.ITEMS[itemId]; if (!itemData) return ''; return `<div class="block p-2 flex flex-col items-center justify-center text-center tooltip"><span class="tooltiptext">${itemData.name}</span><span class="text-3xl">${itemData.icon || '❔'}</span><span class="font-mono text-white mt-1">${quantity.toLocaleString()}</span></div>`; }).join('');
                if (itemsHtml === '') { itemsHtml = `<p class="text-secondary col-span-full text-center">Your bank is empty. Gather some resources!</p>`; }
                return `<h1 class="text-2xl font-semibold text-white mb-4">Bank</h1><div class="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-4">${itemsHtml}</div>`;
            }
            renderMetaSkillsView() {
                const skillsHtml = Object.values(this.game.state.player.meta_skills).map(skill => {
                    let bonusText = '';
                    switch (skill.name) {
                        case META_SKILLS.STRENGTH: bonusText = `Increases combat damage.`; break;
                        case META_SKILLS.INTELLECT: bonusText = `Increases Artisan skill XP gain.`; break;
                        case META_SKILLS.STEWARDSHIP: bonusText = `- ${(skill.level - 1).toFixed(1)}% Gathering action time.`; break;
                        case META_SKILLS.RESILIENCE: bonusText = `+${((skill.level - 1) * 5).toFixed(1)}% Stamina regeneration.`; break;
                        case META_SKILLS.ARTISTRY: bonusText = `Increases Gold from all sources.`; break;
                    }
                    return `<div class="block p-4"><h3 class="text-lg font-bold text-white">${skill.name} - Level ${skill.level}</h3><div class="w-full xp-bar-bg rounded-full h-2 my-2"><div class="xp-bar-fill h-2 rounded-full" style="width:${(skill.currentXP / skill.xpToNextLevel) * 100}%"></div></div><p class="text-xs text-secondary text-right">${Math.floor(skill.currentXP)} / ${skill.xpToNextLevel} XP</p><p class="text-sm text-accent-blue mt-2">${bonusText}</p></div>`;
                }).join('');
                return `<h1 class="text-2xl font-semibold text-white mb-4">Meta Skills</h1><p class="text-secondary mb-4">These skills are leveled up by completing real-life tasks. They provide passive bonuses to your in-game actions.</p><div class="grid grid-cols-1 md:grid-cols-2 gap-4">${skillsHtml}</div>`;
            }
            renderShopView() {
                const chestCards = GAME_DATA.CHESTS.map(c => `
                    <div class="block p-4 flex flex-col justify-between">
                        <div>
                            <h3 class="text-lg font-bold">${c.name}</h3>
                            <p class="text-secondary text-xs">${c.description}</p>
                            <p class="text-secondary text-xs">${c.keyItemID ? 'Requires Key' : 'Cost: ' + c.cost + ' gold'}</p>
                        </div>
                        <button class="buy-chest-btn chimera-button px-3 py-2 rounded-md mt-3" data-chest-id="${c.id}">${c.keyItemID ? 'Open' : 'Buy & Open'}</button>
                    </div>
                `).join('');
                return `<h1 class="text-2xl font-semibold text-white mb-4">Shop</h1><div class="grid grid-cols-1 md:grid-cols-3 gap-4">${chestCards}</div>`;
            }
            renderSkillView(skillId) {
                const skillData = GAME_DATA.SKILLS[skillId];
                const playerSkill = this.game.state.player.skills[skillId];
                let listHtml = '';
                if (skillData.type === 'gathering') {
                    listHtml = (GAME_DATA.ACTIONS[skillId] || []).map(action => {
                        const hasLevel = (playerSkill.level >= action.level);
                        return `
                            <div class="block p-4 flex flex-col justify-between ${!hasLevel ? 'opacity-50' : ''}">
                                <div>
                                    <h3 class="text-lg font-bold text-white">${action.name}</h3>
                                    <p class="text-secondary text-xs">Requires Level: ${action.level}</p>
                                    <p class="text-secondary text-xs">XP: ${action.xp}</p>
                                </div>
                                <div class="mt-4 flex gap-2">
                                    <button class="start-action-btn chimera-button px-4 py-2 rounded-md" data-skill-id="${skillId}" data-action-id="${action.id}" ${!hasLevel || this.game.state.activeAction ? 'disabled' : ''}>Start</button>
                                    <button class="stop-action-btn chimera-button px-4 py-2 rounded-md" data-skill-id="${skillId}" data-action-id="${action.id}" ${(this.game.state.activeAction && this.game.state.activeAction.skillId === skillId && this.game.state.activeAction.id === action.id) ? '' : 'disabled'}>Stop</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    // Artisan
                    const recipes = GAME_DATA.RECIPES[skillId] || [];
                    listHtml = recipes.map(r => {
                        const canAfford = (r.input || []).every(inp => (this.game.state.bank[inp.itemId] || 0) >= inp.quantity);
                        return `
                            <div class="block p-4 flex flex-col justify-between">
                                <div>
                                    <h3 class="text-lg font-bold text-white">${r.name}</h3>
                                    <p class="text-secondary text-xs">Req Lv ${r.level} • XP ${r.xp}</p>
                                </div>
                                <div class="mt-4">
                                    <button class="craft-action-btn chimera-button px-4 py-2 rounded-md" data-skill-id="${skillId}" data-action-id="${r.id}" ${!canAfford ? 'disabled' : ''}>Craft</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
                return `<h1 class="text-2xl font-semibold text-white mb-4">${skillData.name} <span class="text-base text-secondary">(Level ${playerSkill.level})</span></h1><div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">${listHtml}</div>`;
            }

            // ... existing code ...

            attachViewEventListeners() {
                const addTaskBtn = document.getElementById('add-task-btn'); if (addTaskBtn) { addTaskBtn.addEventListener('click', () => { const category = document.getElementById('task-category-select').value; const difficulty = document.getElementById('task-difficulty-select').value; this.game.completeRealLifeTask(category, difficulty); }); }
                const ge = document.getElementById('goto-empire'); if (ge) ge.addEventListener('click', () => { this.currentView = 'clicker'; this.render(); });
                const gw = document.getElementById('goto-woodcutting'); if (gw) gw.addEventListener('click', () => { this.currentView = 'woodcutting'; this.render(); });
                const gr = document.getElementById('goto-runecrafting'); if (gr) gr.addEventListener('click', () => { this.currentView = 'runecrafting'; this.render(); });
                const gc = document.getElementById('goto-combat'); if (gc) gc.addEventListener('click', () => { this.currentView = 'combat'; this.render(); });
                const gs = document.getElementById('goto-shop'); if (gs) gs.addEventListener('click', () => { this.currentView = 'shop'; this.render(); });
                                 document.querySelectorAll('.start-action-btn').forEach(btn => { btn.addEventListener('click', () => { const duration = parseInt(prompt('Enter duration in minutes:', '15'), 10); if (isNaN(duration) || duration <= 0) return; this.game.startAction(btn.dataset.skillId, btn.dataset.actionId, duration); }); });
                document.querySelectorAll('.stop-action-btn').forEach(btn => { btn.addEventListener('click', () => { this.game.stopAction(); }); });
                document.querySelectorAll('.craft-action-btn, .light-action-btn').forEach(btn => { btn.addEventListener('click', () => {
                    const s = btn.dataset.skillId; const a = btn.dataset.actionId;
                    if (s === 'runecrafting') {
                        // handled below
                    } else {
                        this.game.craftItem(s, a, 1);
                        this.render();
                    }
                }); });

                // Runecrafting controls (trimmed for brevity)
                const altar = document.getElementById('altar-dropzone');
                const craftBtn = document.getElementById('rc-craft-btn');
                const btnMinus = document.getElementById('rc-minus');
                const btnPlus = document.getElementById('rc-plus');
                const qtyInput = document.getElementById('rc-qty');
                const qtyRange = document.getElementById('rc-range');
                const haveEss = (this.game.state.bank['rune_essence'] || 0);
                const selectRecipe = (id) => { document.querySelectorAll('.rc-altar-card').forEach(c => c.classList.toggle('rc-selected', c.dataset.rcRecipeId === id)); if (craftBtn) { craftBtn.dataset.recipeId = id || ''; craftBtn.disabled = !id; } };
                document.querySelectorAll('.rc-altar-card').forEach(card => { card.addEventListener('click', () => selectRecipe(card.dataset.rcRecipeId)); });
                document.querySelectorAll('.quick-craft-btn').forEach(btn => { btn.addEventListener('click', (e) => { e.stopPropagation(); const id = btn.dataset.recipeId; const r = (GAME_DATA.RECIPES.runecrafting || []).find(x => x.id === id); if (!r) return; const per = (r.input?.[0]?.quantity || 1); const maxQty = Math.floor((this.game.state.bank['rune_essence'] || 0) / per); if (maxQty <= 0) return; this.game.craftItem('runecrafting', id, Math.min(1, maxQty)); this.render(); }); });
                if (btnMinus) btnMinus.addEventListener('click', () => { const v = Math.max(1, (parseInt(qtyInput.value || '1', 10) - 10)); qtyInput.value = v; if (qtyRange) qtyRange.value = v; });
                if (btnPlus) btnPlus.addEventListener('click', () => { const v = Math.min(haveEss, (parseInt(qtyInput.value || '1', 10) + 10)); qtyInput.value = v; if (qtyRange) qtyRange.value = v; });
                if (qtyInput) qtyInput.addEventListener('change', () => { let v = parseInt(qtyInput.value || '1', 10); if (isNaN(v) || v <= 0) v = 1; v = Math.min(v, haveEss); qtyInput.value = v; if (qtyRange) qtyRange.value = v; });
                if (qtyRange) qtyRange.addEventListener('input', () => { let v = parseInt(qtyRange.value || '1', 10); if (isNaN(v) || v <= 0) v = 1; v = Math.min(v, haveEss); qtyRange.value = v; if (qtyInput) qtyInput.value = v; });
                if (craftBtn) craftBtn.addEventListener('click', () => { const id = craftBtn.dataset.recipeId; if (!id) return; const r = (GAME_DATA.RECIPES.runecrafting || []).find(x => x.id === id); if (!r) return; const per = (r.input?.[0]?.quantity || 1); const maxQty = Math.floor((this.game.state.bank['rune_essence'] || 0) / per); const want = Math.min(maxQty, Math.max(1, parseInt((qtyInput?.value || qtyRange?.value || '1'), 10))); if (want <= 0) return; this.game.craftItem('runecrafting', id, want); if (altar) { for (let i = 0; i < Math.min(10, want); i++) { const spark = document.createElement('div'); spark.className = 'rune-spark'; spark.style.setProperty('--sx', `${(Math.random() - 0.5) * 120}px`); spark.style.setProperty('--sy', `${(Math.random() - 0.2) * 40}px`); spark.style.setProperty('--tx', `${(Math.random() - 0.5) * 40}px`); spark.style.setProperty('--ty', `${-140 - Math.random() * 40}px`); altar.appendChild(spark); setTimeout(() => spark.remove(), 950); } } this.render(); });
                if (altar) { altar.addEventListener('dragover', (e) => { e.preventDefault(); altar.style.borderColor = 'rgba(88,166,255,0.6)'; }); altar.addEventListener('dragleave', () => { altar.style.borderColor = 'var(--border-color)'; }); altar.addEventListener('drop', (e) => { e.preventDefault(); altar.style.borderColor = 'var(--border-color)'; const sel = document.querySelector('.rc-altar-card.rc-selected'); if (!sel) { this.game.uiManager.showFloatingText('Select an altar first', 'text-yellow-300'); return; } const id = sel.dataset.rcRecipeId; const r = (GAME_DATA.RECIPES.runecrafting || []).find(x => x.id === id); if (!r) return; const per = (r.input?.[0]?.quantity || 1); const have = (this.game.state.bank['rune_essence'] || 0); const maxQty = Math.floor(have / per); const want = Math.min(maxQty, Math.max(1, parseInt((qtyInput?.value || qtyRange?.value || '1'), 10))); if (want <= 0) return; this.game.craftItem('runecrafting', id, want); for (let i = 0; i < Math.min(10, want); i++) { const spark = document.createElement('div'); spark.className = 'rune-spark'; spark.style.setProperty('--sx', `${(Math.random() - 0.5) * 120}px`); spark.style.setProperty('--sy', `${(Math.random() - 0.2) * 40}px`); spark.style.setProperty('--tx', `${(Math.random() - 0.5) * 40}px`); spark.style.setProperty('--ty', `${-140 - Math.random() * 40}px`); altar.appendChild(spark); setTimeout(() => spark.remove(), 950); } this.render(); }); }
                const essenceToken = document.getElementById('essence-token'); if (essenceToken) { essenceToken.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', 'essence'); }); }

                // Combat
                document.querySelectorAll('.start-combat-btn').forEach(btn => { btn.addEventListener('click', () => { this.game.startCombat(btn.dataset.enemyId); this.currentView = 'combat'; this.render(); }); });
                const endBtn = document.getElementById('end-combat-btn'); if (endBtn) endBtn.addEventListener('click', () => this.game.endCombat(false));
                document.querySelectorAll('.eat-food-btn').forEach(btn => { btn.addEventListener('click', () => this.game.eatFood(btn.dataset.itemId)); });
                document.querySelectorAll('.equip-weapon-btn').forEach(btn => { btn.addEventListener('click', () => this.game.equipWeapon(btn.dataset.itemId)); });

                // Empire hiring events
                document.querySelectorAll('.hire-unit-btn').forEach(btn => { btn.addEventListener('click', () => this.game.hireEmpireUnit(btn.dataset.unitId)); });

                // Spells
                document.querySelectorAll('.cast-spell-btn').forEach(btn => { btn.addEventListener('click', () => this.game.castSpell(btn.dataset.spellId)); });
                // Shop
                document.querySelectorAll('.buy-chest-btn').forEach(btn => { btn.addEventListener('click', () => this.game.buyChest(btn.dataset.chestId)); });
                // Army
                document.querySelectorAll('.hire-army-btn').forEach(btn => { btn.addEventListener('click', () => this.game.hireArmyUnit(btn.dataset.unitId)); });
                const rallyBtn = document.getElementById('rally-army-btn'); if (rallyBtn) rallyBtn.addEventListener('click', () => this.game.rallyArmy());
                const resetBtn = document.getElementById('reset-save'); if (resetBtn) resetBtn.addEventListener('click', () => this.game.resetSave());

                // Expeditions
                document.querySelectorAll('.launch-expedition-btn').forEach(btn => { btn.addEventListener('click', () => { const id = btn.dataset.expId; const share = parseFloat(btn.dataset.share || '0.25'); this.game.launchExpedition(id, share); }); });
                document.querySelectorAll('.recall-expedition-btn').forEach(btn => { btn.addEventListener('click', () => { const idx = parseInt(btn.dataset.exIndex, 10); this.game.recallExpedition(idx); }); });

                // Workers - generic per skill
                document.querySelectorAll('.hire-worker-btn').forEach(btn => { btn.addEventListener('click', () => this.game.hireWorker(btn.dataset.skillId)); });
                document.querySelectorAll('.upgrade-worker-btn').forEach(btn => { btn.addEventListener('click', () => this.game.upgradeWorkers(btn.dataset.skillId, btn.dataset.type)); });
                document.querySelectorAll('.assign-worker-btn').forEach(btn => { btn.addEventListener('click', () => { const skillId = btn.dataset.skillId; const actionId = btn.dataset.actionId; const dir = btn.dataset.dir === '+1' ? 1 : -1; const ws = this.game.state.workers?.[skillId]; if (!ws) return; const free = (ws.total || 0) - Object.values(ws.assigned).reduce((s, n) => s + (n || 0), 0); if (dir > 0 && free <= 0) return; ws.assigned[actionId] = Math.max(0, (ws.assigned[actionId] || 0) + dir); this.render(); }); });
            }

            // ... existing code ...

            renderArmyView() {
                const defs = GAME_DATA.ARMY_CLASSES;
                const owned = this.game.state.army.units || {};
                const out = this.game.calculateArmyOutputPerSecond();
                const hungry = this.game.state.army.upkeep?.hungry || false;
                const canRally = (this.game.state.player.runes || 0) >= 1 && !this.game.hasBuff('armyRally');
                const cards = Object.keys(defs).map(id => {
                    const d = defs[id];
                    const qty = owned[id] || 0;
                    const cost = this.game.getArmyUnitCost(id);
                    const stats = [];
                    if (d.dps) stats.push(`DPS ${d.dps}`);
                    if (d.hps) stats.push(`HPS ${d.hps}`);
                    stats.push(`Food/min ${d.foodPerMin}`);
                    return `
                        <div class="block p-4 flex flex-col justify-between">
                            <div>
                                <h3 class="text-lg font-bold">${d.emoji} ${d.name} <span class="text-xs text-secondary">(${d.role})</span></h3>
                                <p class="text-secondary text-xs">${d.description}</p>
                                <p class="text-secondary text-xs mt-1">${stats.join(' • ')}</p>
                                <p class="text-white text-sm mt-2">Hired: <span class="font-mono">${qty}</span></p>
                            </div>
                            <button class="hire-army-btn chimera-button px-3 py-2 rounded-md mt-3" data-unit-id="${id}">Recruit — Cost: ${cost} gold</button>
                        </div>
                    `;
                }).join('');
                return `
                    <h1 class="text-2xl font-semibold text-white mb-4">Army</h1>
                    <div class="block p-4 mb-4">
                        <h2 class="text-lg font-bold">Logistics</h2>
                        <p class="text-secondary text-sm">Allied Output: <span class="text-white">DPS ${out.dps.toFixed(1)} • HPS ${out.hps.toFixed(1)}</span> • Upkeep: <span class="text-white">${out.foodPerMin.toFixed(1)} food/min</span> ${hungry ? '<span class="ml-2 text-red-400">Hungry (-50% effectiveness)</span>' : ''}</p>
                        <p class="text-xs text-secondary mt-1">Cook food in Cooking to sustain a larger army. Upkeep consumes cooked items from your Bank automatically.</p>
                        <div class="mt-2 flex items-center gap-2">
                            <button id="rally-army-btn" class="chimera-button px-3 py-2 rounded-md" ${canRally ? '' : 'disabled'}><i class="fas fa-bullhorn"></i> Rally Horn — Cost: 1 Rune</button>
                            ${this.game.hasBuff('armyRally') ? '<span class="badge"><i class="fas fa-fire"></i> Rally Active</span>' : ''}
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${cards}</div>
                `;
            }

            // ... existing code ...
        }

        const game = new GameManager(); game.init(); window.chimeraGame = game;
    });
    </script>
</body>
</html>